 www.cnblogs.com/Liang2021/p/16453493.html
 Algorithm
    时间复杂度(更关注)---渐进时间复杂度
        空间复杂度相对来讲不是那么地关注,毕竟有周转的余地(加内存)

        事后分析法
            不推荐,先要把代码写出来,执行之后才知道效率,并且执行也依赖于测试环境,会导致结果不一致,数据的性质和规模对测试也有很大的影响,数据量太小了体现不出来

        O时间复杂度表示法
            表示的是一种趋势,而不是具体的执行时间
            T(n)=O(f(n))
                n 表示数据规模的大小
                f(n) 表示"执行次数"的总和,是n的某个函数
                T(n) 代表总时间 

                T(n)的增长率是和f(n)相对应的

                O(n)并不代表代码执行时间,只是代表执行时间随着数据规模增长的一个变化趋势,是个函数拿来参考的
            所以称之为渐进时间复杂度,简称时间复杂度
        时间复杂度分析
            1. 只关注循环执行次数最多的一段代码
            2. 总复杂度等于最高阶项的复杂度
            3. 嵌套代码的时间复杂度等于嵌套内外代码复杂度的乘机

            只要执行的次数是个常数,和n无关,那么照样是个常量级别的时间复杂度,管你是1k次 1w次,"都可以忽略掉",对增长趋势没什么影响
            O时间复杂度表示的是一种趋势,不是具体的执行时间之类的

            推导大O阶
                1. 用常数1取代运行时间中的所有加法常数
                2. 在修改后的运行次数函数中,只保留最高阶项
                3. 如果最高阶项存在不是1,则去除与这个项相乘的常数.得到的结果就是大O阶

                eg: 3n²+n+100--->n²
            常见时间复杂度
                O(1)--->常数阶   
                    只要时间复杂度不随n的增大而增大,都被记为O(1),换句话说只要程序中不存在与n相关的循环语句/递归...,即便有成千上万条,那也是O(1)
                O(n)--->线性阶
                O(n²)--->平方阶
                O(n³)--->立方阶
                O(logn)--->对数阶
                    while(i<=n){
                        // i=i*2;   logn--->以2为底
                        i=i*3;   log3ⁿ
                    }
                    记录的时候,不管以多少为底,都记为logn,因为对数之间可以进行转换
                        eg: log3ⁿ=log3² * log2ⁿ(logn)
                            这样再简化一下,实际上那log3²(常数阶)就被省略了,log3ⁿ最终取的就是log2ⁿ(logn),那所以说,最终都可以转换成logn
                        这就是为什么统一计成logn
                O(nlogn)--->线性对数阶
                    for(i=1;i<=n;i++){
                        while(i<=n){
                            // i=i*2;   logn--->以2为底
                            i=i*3;   log3ⁿ
                        }
                    }
                    这个时间复杂度就是nlogn
                O(2ⁿ)--->指数阶
                O(n!)--->阶乘阶

                O(1)<O(logn)<O(n)<O(nlogn)<O(n²)<O(n³)<O(2ⁿ)<O(n!)<(nⁿ)

                一般如果时间复杂度达到 n³,那么这个时间复杂度在工程应用上就没什么意义了
                后面的就是非多项式量级---NP,当n足够大的时候,NP时间复杂度会急速增加,属于非常机械的算法

                也会出现有多个变量决定的时间复杂度  O(m+n)...
    空间复杂度---渐进空间复杂度
        如果一个算法里面辅助变量的空间相对于输入的数据量来讲是一个常数,这个算法称之为原地工作---空间复杂度统称为O(1)
            void print(int n){
                int i=0;
                int[] a=new int[n];
                for(i=1;i<=n;i++){
                    a[i]=i*i;
                }
            }
            这个空间复杂度实际上就是O(n),即便下面有循环,但是没有新增空间
    递归
        用递归的条件
            1. 一个问题的解可以分解为几个子问题的解
            2. 这个问题与分解之后的子问题,除了数据规模不同,"求解思路完全一样"
            3. 存在基线(什么时候需要调用自己)+终止(什么时候终止调用)条件
        可能存在的问题
            递归的空间复杂度是比较高的(压栈出栈)
            可能会存在堆栈溢出
            可能耗时也比较多
            "也可能会导致重复计算的问题"
                不是单纯地调用一次自己本身的时候,而是f(n-1)+f(n-2)这种,那么比如计算了f(5)=f(4)+f(3)  而计算f(4)的时候,f(4)=f(3)+f(2) 这样实际f(3)就重复计算了 
        所以开发过程中应不应该使用递归,需要根据实际情况来决定
        "理论上来讲,所有的递归代码都可以转换成循环来解决"
    快排的时间复杂度
        O(nlogn)
算法
    基础
        二进制
            负数的二进制表示
                第一位是符号位,1表示负数,0表示非负数
                怎么算
                    所有位取反(~)(可以包含符号位一起取反),然后再+1,得到的值就是数值部分,把他变成负的即可
                    
                    最小的int值二进制表示: 
                        10000000000000000000000000000000 
                            符号位是1,表示当前是个负数,1往后全取反,然后变成11111111111111111111111111111111,再+1,进位得到最小值 (- 2的31次方)

                            进位就是不管符号位了
                    -1 的二进制表示
                        11111111111111111111111111111111
                为啥负数要取反再+1呢,因为在设计的时候想的是 加减乘除 底层都用一套逻辑来进行实现,而不是对不同的算术运算定制一套规则
                    虽然看起来比较deer/复杂,但是操作的逻辑都是一套,实际执行的时候会快一些,不用再去区分这是正数还是负数
                    原码 反码 补码
            >>和>>>
                >>
                    带符号右移
                        右移之后,左侧不得填充吗? 用什么填充,之前的符号位是什么就用什么填充(但是往后移动,符号位不会往后移动)
                        就相当于 除以2
                >>>
                    不带符号右移
                        右移之后,左侧都用0进行填充
                        就相当于 除以2之后的绝对值?
            一个数的相反数
                概述
                    取反(符号位也要变) 再+1
                比如5的相反数
                    int a=5;
                    int b=-a;
                    or
                    int a=5;
                    int b=(~a+1);

                加法 
                    正数+负数 就是正数 + (负数对应的正数 取反 +1)
                    走的都是一套转换逻辑
                注意(负数的最小值没有对应的相反数)---特殊
                    任何一个正数都有一个对应的相反数,但是因为负数表示的范围比正数范围多一个(-2的31次方),这个数是找不到对应的相反数的
                    "它取相反数之后,值还是他自己"

                    int a=Integer.MIN_VALUE;
                    int b=-a;
                    a和b的值是一样的
                        就算取反 +1, 值还是10000000000000000000000000000000
                    所有系统/语言都是这样的

                0的相反数还是自己
                    取反之后11111111111111111111111111111111,再+1,左侧溢出,溢出就是不要了,剩下的32位还是全为0,所以值还是0 
        位图
            %运算
                比如 a % 64, 结果就是把a的7位之前的二进制都变成0, 那这就是相当于 a&(64-1), 完全可以用 & 替代 %, 快得多, 但是只适合于对 2的某次方 取模
            思想 
                用long/int数组来模拟bit数组, long数组每一个下标表示64个数组存不存在, 0号下标表示0~63, 1号下标表示64~127的值是否存在, 存在即将那个位置变为1, 只不过要变成数组整数实现, 不是单纯的bit[] 
            代码实现
                public class BitMap {
                    // 用long类型的数组模拟实现bit数组
                    public final long[] bits;

                    /**
                    * 初始化位图大小
                    *
                    * @param max 位图能记录的最大范围， 比如 1024...
                    */
                    public BitMap(int max) {
                        bits = new long[(max + 64) >> 6];
                    }

                    /**
                    * 向位图中添加元素
                    * 思路
                    * 先根据num定位到是数组的哪个下标
                    * 然后根据下标去改变对应的值, 将下标对应的值的指定位置的二进制变成1
                    * 先用num对64取模， 获取到是哪个位置的二进制, 然后1L左移动取模的值
                    *
                    * @param num 要添加的值
                    */
                    public void add(int num) {
                        // 定位到是数组的哪个下标
                        int targetIndex = num >> 6;
                        int mod = num & 63;
                        bits[targetIndex] |= (1L << mod);
                    }

                    /**
                    * 从位图中移除元素, 就是把位图中对应位置的二进制1变成0
                    *
                    * @param num 要移除的元素
                    */
                    public void remove(int num) {
                        int targetIndex = num >> 6;
                        int mod = num & 63;
                        bits[targetIndex] &= (~(1L << mod));
                    }

                    /**
                    * 判断位图中是否存在对应的值
                    *
                    * @param num 要进行判断的值
                    * @return true/false
                    */
                    public boolean contains(int num) {
                        int targetIndex = num >> 6;
                        int mod = num & 63;
                        return (bits[targetIndex] & (1L << mod)) != 0;
                    }
                }
        位运算实现加减乘除⭐️
            注意
                自己手写的位运算实现加减乘除是没有java自己的快的, jvm里面有汇编之类的, 自己写的到底层还是要转一下, 那肯定没有人家的好啊
            思路 
                无进位相加
                    异或运算就是无进位相加 (1和1相加本来该进位的, 但是不仅为,只是变成了0, 不是说整体相加结果不进位啥的)
                进位相加
                    两个数&了之后, 然后结果左移一位
                    本来&嘛,有两个1就是1, 那么这个位置就应该进位一下, 所以&完之后左移1位, 就代表是进位相加的结果
                (a+b)的结果 = 无进位相加 + 进位相加 
                    但是呢, 又不能使用+号, 所以一样, 把这两 接着无进位和进位相加, 直到"进位相加"的结果为0, 此时无进位相加的结果就是 "结果"⭐️
            代码实现
                加
                    public static int add(int a, int b) {
                        // 无进位相加
                        int noCurry = a ^ b;
                        // 进位相加
                        int curry = (a & b) << 1;
                        int sum = noCurry;
                        while (curry != 0) {
                            sum = noCurry ^ curry;
                            curry = (noCurry & curry) << 1;
                            noCurry = sum;
                        }
                        return sum;
                    }
                减
                    相反数
                    private static int getOppositeNum(int num) {
                        return add(~num, 1);
                    }
                    a+(b的相反数)
                    public static int minus(int a, int b) {
                        return add(a, getOppositeNum(b));
                    }
                乘
                    跟小学乘法的思路是一样的， 只不过涉及到是b无符号右移， a有符号左移
                    当b不为0时，结果加上a
                    public static int multi(int a, int b) {
                        int res = 0;
                        while (b != 0) {
                            // 看看b此时当前位是否为1, 会右移
                            if ((b & 1) != 0) {
                                // 此时结果加上a
                                res = add(res, a);
                            }
                            a <<= 1;
                            b >>>= 1;
                        }
                        return res;
                    }
                除
                    public static int divide(int a, int b) {
                        // 先获取他两各自的绝对值
                        int x = a < 0 ? getOppositeNum(a) : a;
                        int y = b < 0 ? getOppositeNum(b) : b;

                        int res = 0;
                        // a右移
                        for (int i = 30; i >= 0; i = minus(i, 1)) {
                            // 如果移动到i位置之后发现比y大， 说明可以搞
                            if ((x >> i) >= y) {
                                // 将此时的(1<<i)加到res中
                                res |= (1 << i);
                                // x减去此时(y<<i)
                                x = minus(x, (y << i));
                            }
                        }
                        return a < 0 ^ b < 0 ? getOppositeNum(res) : res;
                    }


    复杂度+对数器+二分法
        固定时间操作
            常数操作
                计算机中,对于常数操作,实际上性能和时间都是一样的,比如 1+1 和 10000+10000 都是一样的,底层都是32位(4个字节8个位),所以两个计算的复杂程度都是一样的 
            寻址操作
                一个容量为1000w的数组,拿其中200w处的数据和800w处的数据 时间是基本固定的
                    内存中可能存在有限级的跳转,但是就把它当做是连续的一块空间就可以了
        非固定时间操作
            比如LinkedList链表中去找值,第200w的数据和第800w肯定不一样,内存中地址都不是连续的
        常数时间操作 O(1)
        时间复杂度
            最重要的评估算法优劣的核心指标
            "数据状况"会影响算法表现的时候,要用"最差的情况"来"估计时间复杂度"
                O() 就是最差情况下--->渐近线的上限
                Ω() 平均情况
        额外空间复杂度
            概述
                要实现一个算法流程,实现的过程中,肯定涉及到开辟一些空间来支持整个流程
                对于输入参数的空间,不算额外空间
                对于输出结果的空间,也不算额外空间
                    比如让拷贝一个数组(不让动原数组),好,那么我们在实现的时候会搞一个新数组(大小和输入的数组是一样的),那么这个额外空间复杂度就是O(1),因为这个新数组是输出结果的空间,必须使用的空间,不算额外空间,输入也不算
                因为这些都是必要的
                除此之外开辟的空间,就是额外空间
                    比如说实现的过程中可能需要用到一个HashMap去进行存储临时的数据,而这个HashMap呢又不需要返回,所以这个额外空间复杂度就是O(n)/或者其他的
                如果流程只需要开辟"有限几个变量",额外空间复杂度就是O(1)

            说白了,"就是和输入输出无关的,程序员自主空间"
        常数项时间
            常见的常数项时间
                常见的算数符
                常见的位运算(>>(带符号左移),>>>,<<,|,&,^)
                赋值,比较,自增,自减等操作
                数组寻址操作
                ...
            O(N)不论如何肯定要比O(N²)的好
            如果两个算法的时间复杂度都一样,那么时间一定一样吗?这肯定就不一样了,这个时候就要拼常数项的阶段(a*n²+b*n+c) 这个时候就要拼abc
            比如说 
                冒泡排序和插入排序,两个时间复杂度都是O(N²),但是实际上插入排序就是比冒泡好,很多数据状况下表现就是比冒泡好
            怎么拼常数项的值
                "只能直接实测"
                不同的常数的操作也是有时间差的
                +就没有^操作快,/就没有+操作快

            总之,执行时间是固定的操作都是常数时间的操作
            反之,执行时间不是固定的操作,跟数据量有关的,都不是常数时间的操作
        一个问题的最优解是什么?
            时间复杂度要尽可能的低,然后,使用最少的空间的算法流程--->最优解
            
            一般最优解都是"忽略掉常数项这"个因素的,因为常数项只决定了"实现层次"的优化和考虑,和怎么解决问题的"思想"无关
        时间复杂度排序
            O(1)<O(logn)<O(n)<O(nlogn)<O(n²)<O(n³)<O(n的k次方)<O(2ⁿ)<O(3ⁿ)<O(Kⁿ)<O(n!)<(nⁿ)
        排序算法
            选择排序
                思路
                    选个最小的,依次放到第一个,第二个位置... 
                    将最小的元素放到最前
                代码 
                    public static void selectionSort(int[] arr) {
                        if (arr == null || arr.length < 2) {
                            return;
                        }
                        for (int i = 0; i < arr.length - 1; i++) {
                            for (int j = i + 1; j < arr.length; j++) {
                                if (arr[j] < arr[i]) {
                                    //交换
                                    int temp = arr[i];
                                    arr[i] = arr[j];
                                    arr[j] = temp;
                                }
                            }
                        }
                    }
            冒泡排序
                思想
                    当前元素和下一个元素进行对比,如果比下一个元素大,就进行替换
                    外层循环总共走arr.length-1次
                    内层循环是跟i有关,arr.length-i-1次
                    将最大的元素放到最后
                代码
                    普通
                        public static void bubbleSort(int[] arr) {
                            if (arr == null || arr.length < 2) {
                                System.out.println(Arrays.toString(arr));
                                return;
                            }
                            for (int i = 0; i < arr.length - 1; i++) {
                                for (int j = 0; j < arr.length - i - 1; j++) {
                                    if (arr[j] > arr[j + 1]) {
                                        int temp = arr[j];
                                        arr[j] = arr[j + 1];
                                        arr[j + 1] = temp;
                                    }
                                }
                            }
                            System.out.println(Arrays.toString(arr));
                        }
                    优化
                        public static void bubbleSortOptimization(int[] arr) {
                            if (arr == null || arr.length < 2) {
                                return;
                            }
                            boolean flag = false;
                            for (int i = 0; i < arr.length; i++) {
                                flag = false;
                                for (int j = 0; j < arr.length - i - 1; j++) {
                                    if (arr[j] > arr[j + 1]) {
                                        int temp = arr[j];
                                        arr[j] = arr[j + 1];
                                        arr[j + 1] = temp;
                                        flag = true;
                                    }
                                }
                                // 如果此时flag仍旧为false,那么说明这次循环下来,后面的元素都没有进行交换过,说明什么?说明此时后面的元素全部都已经有序了,那也就无需进行下面的循环了,直接返回
                                if (!flag) {
                                    return;
                                }
                            }

                        }
                
            插入排序
                思想
                    就像是打牌,手里有一手牌了,然后又抓起来一张,将它放到合适的位置
                    保证从0-0,0-1,0-2,0-3,0-(n-1)一直都有序,而且从一开始就保证有序,所以走到后面的时候只需要交换就可以保证在这一段之内是有序的
                代码 
                    public static void insertionSort(int[] arr) {
                        if (arr == null || arr.length < 2) {
                            return;
                        }
                        // 0-1
                        // 0-2
                        // 0-3
                        // ...
                        for (int i = 1; i < arr.length; i++) {
                            // j代表当前i的前一个数的索引,往前遍历,直到为0
                            for (int j = i - 1; j >= 0; j--) {
                                if (arr[j] > arr[j + 1]) {
                                    // 交换
                                    int temp = arr[j];
                                    arr[j] = arr[j + 1];
                                    arr[j + 1] = temp;
                                }else {
                                    // 如果前一个本来就比当前的小,而前面的数据又已经进行了排序,那么此时当前的这个数据就不需要再往前面比对了,说明到这里为止,这些数据就是有序的
                                    // 这是相对于冒泡是优化了一下,有好的数据状况的时候,性能要比冒泡好,因为数据有序的话直接不比对了,而冒泡尽管数据条件再好,仍旧是要过一遍
                                    break;
                                }
                            }
                        }
                    }
                时间复杂度
                    O(n²)
            希尔排序
                思想 
                    其实本质上也是一种"插入排序",但是有一个增量gap,gap逐渐缩小,每一次保证在gap增量中保持有序
                时间复杂度 
                    希尔排序是n的1.3~2次方,但是O(n的1.3 次方)没有O(nlogn)好
                代码 
                    public static void shellSort(int[] arr) {
                        if (arr == null || arr.length == 0) {
                            return;
                        }
                        // 增量+插入排序
                        // 设置初始增量为数组长度的一半
                        int gap = arr.length / 2;
                        while (gap >= 1) {
                            // 进行gap增量的插入排序
                            int gapIndex = gap;
                            for (int i = gapIndex; i < arr.length; i++) {
                                // 和前面相隔gap个位置元素(j-gap)做对比,j-gap-gap,j-gap,j 这个上面做插入排序
                                // 因为是从gapIndex(gap)开始的，所以一次扫过去比对就可以保证有序
                                for (int j = i; j - gap >= 0; j -= gap) {
                                    // 如果arr[j-gap]>arr[j],交换
                                    if (arr[j - gap] > arr[j]) {
                                        // 交换
                                        int temp = arr[j];
                                        arr[j] = arr[j - gap];
                                        arr[j - gap] = temp;
                                    }else {
                                        break;
                                    }
                                }
                            }
                            gap /= 2;
                        }
                        System.out.println(Arrays.toString(arr));
                    }
        对数器
            自己造测试数据,创造出小范围的报错测试用例,大样本随机测试
            一个正确的程序
        二分法
            二分查找
                思想
                    前提是一个有序数组,那么有序之后,每次去查就查中间的那个,因为是有序的,所以就可以根据中间那个进行快速判断,减少比对次数,从而降低时间复杂度,中间值大于目标值,right=middle-1,中间值小于目标值,left=middle+1

                    有两种判断临界条件,
                        left<right,这种是循环走完之后,left=right,那么也就是还剩下一个值没有判断
                        left<=right,这种是循环走完之后,left>right left=right+1,那么就是最后一个值在循环中也进行判断了,那么跳出循环后,没啥可判断的了
                时间复杂度 O(logN)
                代码
                    public static boolean binarySearch(int[] sortedArr, int num) {
                        if (sortedArr == null || sortedArr.length == 0) {
                            return false;
                        }

                        int right = sortedArr.length - 1;
                        int left = 0;
                        int middle = 0;

                        // left<right,意味着循环走完,索引指针指向最后一个没有判断过的元素
                        while (left < right) {
                            // 这里不能写成left+right,因为可能会溢出,如果left是20多亿,right也是20多亿,left+right肯定就已经超出int的范围了
                            middle = left + ((right - left) >> 1);

                            if (sortedArr[middle] == num) {
                                return true;
                            } else if (sortedArr[middle] > num) {
                                // right要往左边移动
                                right = middle - 1;
                            } else {
                                // left要往右边移动
                                left = middle + 1;
                            }
                        }

                        // 循环结束,如果走到这里,说明上面的循环都没找到,然后锁定到的肯定就是一个值,此时应该是left=right,两个相等,随便取出哪一个
                        return sortedArr[right] == num;
                    }
            找到>=value的最左边的值
                代码
                    public static int nearestIndex(int[] arr, int value) {
                        if (arr == null || arr.length == 0) {
                            return -1;
                        }

                        int right = arr.length - 1;
                        int left = 0;
                        int middle = 0;
                        int index = -1;

                        // left <= right, 意味着循环结束, 不存在没有扫到过的元素, 包括最后一个元素都已经检验过了
                        while (left <= right) {

                            middle = left + ((right - left) >> 1);

                            if (arr[middle] >= value) {
                                //此时说明符合条件的最左边值的索引可能在左边
                                right = middle - 1;
                                //记录index
                                index = middle;
                            } else {
                                //说明符合条件的索引在右边
                                left = middle + 1;
                            }
                        }
                        return index;
                    }
            获取一个无序数组(相邻的元素一定不相等)中局部最小值的索引
                代码
                    public static int getLessIndex(int[] arr) {

                        if (arr == null || arr.length == 0) {
                            return -1;
                        }

                        // 判断第一个元素是否比第二个元素小,是,则返回
                        if (arr[0] < arr[1]) {
                            return 0;
                        }
                        int length = arr.length;
                        // 判断最后一个元素是否比倒数第二个元素小,如果是,则返回
                        if (arr[length - 1] < arr[length - 2]) {
                            return length - 1;
                        }

                        // 当上面都不满足时,就要二分了
                        int right = length - 2;
                        int left = 1;
                        int middle = 0;

                        while (left < right) {
                            middle = left + ((left - right) >> 1);
                            if (arr[middle - 1] < arr[middle]) {
                                // 此时right应该为middle-1
                                right = middle - 1;
                            } else if (arr[middle] > arr[middle + 1]) {
                                left = middle + 1;
                            } else {
                                return middle;
                            }
                        }
                        return right;
                    }
            二分的总体思想
                有一半肯定有,另一半不确定,排他性,一次只走一边,然后找一个出来
                L+R 可能溢出
                >>比/快得多
    异或
        异或^
            相同为0,不同为1
            不同的为异,异就为1

            也叫"无进位相加",就是如果1+1加了之后按理来讲应该进一位,那么异或就是相加之后不要这个进位,只要一个0
                偶数个1相加,就是0,奇数个1相加就是0
            0^N=N N^N=0 A^B=B^A (A^B)^C=A^(B^C)
            满足交换律和结合律

        同或
            相同为1,不同为0
            相同为1
        题目
            如何不用额外变量交换两个数?
                a = a ^ b;
                b = a ^ b;  
                a = a ^ b;
                把a和b看做甲和乙,甲^乙^乙=甲,甲^乙^甲=甲
                是按照0^N=N,N^N=0 这个规则来的
            一个数组中有一种数出现了奇数次,其他数都出现了偶数次,怎么找到并打印这个数?
                常规解法: HashMap存储一个数出现的次数
                异或解法
                    根据异或的特性,异或偶数个的数结果为0,异或奇数个的数的结果为这个数,所以定义一个变量 int eor=0,让它去对数组中的每一个值进行异或操作,那么最后eor的值就是这个出现了奇数次的数,因为出现欧数次的数最终都会被异或为0,奇数次就是它本身,同时本身异或运算跟顺序也无关
                代码
                    public static void printOddOnceTimeNum(int[] arr) {
                        int eor = 0;
                        for (int i = 0; i < arr.length; i++) {
                            eor ^= arr[i];
                        }
                        System.out.println(eor);
                    }
            把一个int类型的数,提出最右侧的1来(说明这个数的右侧都是0)⭐️
                题意
                    就是比如说我现在一个int类型的数,用二进制表示是 0110111001000
                    那我要得到二进制为 0000000001000
                    怎么实现呢?
                a&((~a)+1)
                    ~a 就是取反
                    ~a+1就是 -a
                a&(-a)
                思路
                    先取反,取反是为了让每一个位的值都不一样,然后再加1,加1是因为这个在取反之后,最右侧的1就变成0,然后他的右边全部变成了1,然后加1,那它右边肯定又变成了0,它自己肯定也变回了1,而且对前面的数不影响,此时的数就是 1001000111000, 再拿着这个数去和原始的数进行&运算(只有两个同时为1的时候才为1),那么就可以保证前面的数全部为0,后面的数也全部为0,只剩下那个1

                    要让其他位变为0,那么就可以考虑&运算,只要两个不同/两个不同时为1,好那这个操作可以考虑取反去实现,那要实现只有那一个位置和之前相同呢? 利用是最右侧的1嘛,那么就取反之后+1,那么此时目标位置就是1,后面都是0,前面不影响,然后这个时候的数再和原来的数&一下,就可以实现
            一个数组中有两种数出现了奇数次,其他的数都出现了偶数次,如何找到这个两个数?
                代码
                    public static void printOddTwiceTimeNum(int[] arr) {
                        int eor = 0;
                        for (int i = 0; i < arr.length; i++) {
                            eor = eor ^ arr[i];
                        }
                        System.out.println("eor " + eor);
                        // eor=a^b
                        // 取得eor最右侧的1, eor这个位置为1, 说明a和b这个位置一个为1一个为0, 那么就分开了
                        // 而数组中的所有数, 这个位置也是要么是1,要么是0, 所以就可以分为两大类, a和b分别在一类中

                        // 这个时候我们再去对所有的数进行异或运算,但是只对其中一类进行异或,也就是要判断这个位置是否为1 或者是否为0, 因为一类里面,最终走下来,里面要么出现了奇数次,要么出现了欧数次
                        // 异或完之后, 可以排除掉出现偶数次的,那么剩下的就是那一个出现了奇数次的
                        int rightOne = eor & (-eor);
                        System.out.println("rightOne " + rightOne);
                        int newEor = 0;
                        for (int i = 0; i < arr.length; i++) {
                            // 把这个位置为1的挑选出来 (arr[i] & rightOne) == 0 也行
                            if ((arr[i] & rightOne) != 0) {
                                newEor = newEor ^ arr[i];
                            }
                        }
                        System.out.println("newEor " + newEor);
                        // 此时newEor就是那个 指定位置为1的奇数
                        System.out.println("one is " + newEor);
                        int secOne = eor ^ newEor;
                        System.out.println("another one is " + secOne);
                    }
            一个数组中有一种数出现了k次,其他的数都出现了m次,k<m并且m>1, 请找到这个出现了k次的数
                代码
                    public static int printKM(int[] arr, int k, int m) {
                        // 因为是个int类型的数组, 所以每个元素最多长度为32位, 那么定义一个32长度的数组
                        int[] temp = new int[32];
                        // 先将每一个元素都转换为二进制
                        // 然后根据二进制,遍历一个元素就将这个数加到这个32位长度的int数组中,用来标记每一个位都多少个重复的
                        for (int i = 0; i < arr.length; i++) {
                            for (int j = 0; j < 32; j++) {
                                // 将当前arr中的元素,往右移动j(0<=j<32)位,然后和1进行&运算,这样可以计算出当前的j位是否为1
                                if (((arr[i] >> j) & 1) != 0) {
                                    // 说明arr[i]的第j个位置 是1, 那么对temp[j]进行相加
                                    temp[j]++;
                                }
                            }
                        }
                        // 循环走完之后,此时temp数组里就存了对应的那些值
                        int res = 0;
                        // 如果某一个位置,对M取余为0, 那么说明这个位置存的全是出现了M次的数, 反之如果不为0, 那么这个位置存的数就同时包含 出现了K次和M次的数
                        for (int i = 0; i < 32; i++) {
                            if (temp[i] % m != 0) {
                                // 说明这个时候就有出现了k次的数
                                // 那么只要我们把这个k次的数找出来就行,怎么找呢? 因为如果有k次的数,那它的这个位置肯定为1,好,那就把这些1都合起来
                                res = res | (1 << i);
                            }
                        }
                        System.out.println("出现了" + k + "次的数:" + res);
                        return res;
                    }
    基本的数据结构
        单链表
            node.next=null;
            null在内存中是一块单独的区域,一个变量为null,那么就是它指向这个null的区域
            题目
                单链表的反转
                    代码
                        public static Node reverseSingleList(Node head) {
                            if (head == null || head.next == null) {
                                return head;
                            }
                            Node pre = null;
                            Node next = null;
                            while (head != null) {
                                next = head.next;
                                head.next = pre;
                                pre = head;
                                head = next;
                            }
                            return pre;
                        }
                删除链表中的所有指定的值
                    注意
                        要注意跳过头结点,如果头结点(连续)就是指定的值,那么要注意这些
                        while(head!=null){
                            if(head.value!=num){
                                break;
                            }
                            head=head.next;
                        }
            对数器
                可以放容器里(数组),然后将数组中的元素都添加到一个链表中
        栈+队列(是一种逻辑上的数据结构)
            都可以用链表实现,而且可能相对数组来讲还简单一些
            队列
                双端队列(Head节点+Tail节点完事)
                    可以从头进,从头处,也可以从尾进,从尾出
                双链表实现(Head节点+Tail节点完事)
                    新增一个节点就在Tail节点的next加上,Tail后移
                    弹出一个节点,就是获取Head节点,然后Head节点往后移动
                循环/环形数组实现实现(begin+end+size)---size管一切
                    思路
                        添加的时候先判断size,如果没有等于最大容量,那么就可以加,然后end++(注意索引)
                        弹出的时候,判断size==0? 如果等于0, 那么队列就空了,没法再弹出,如果不等于0,那么begin++(注意索引)
                        这种根本就不需要去管循环数组中的那种情况,end有没有追上begin之类的
                    代码实现
                        public class MyQueue {
                            // 实际用来存放数据的数组
                            private int[] arr;
                            private int pushIndex;
                            private int popIndex;
                            private final int limit;
                            private int size;

                            /**
                            * 初始化，设置pushIndex，popIndex，size都为0，limit为指定值表示数组长度，初始化数组
                            *
                            * @param limit
                            */
                            public MyQueue(int limit) {
                                this.arr = new int[limit];
                                this.pushIndex = 0;
                                this.popIndex = 0;
                                this.limit = limit;
                                this.size = 0;
                            }
                            public void push(int value) {
                                if (size >= limit) {
                                    System.out.println("当前队列已满，无法再添加元素");
                                    return;
                                }
                                size++;
                                // pushIndex位置进行设置
                                arr[pushIndex] = value;
                                // pushIndex往后移动，但是注意循环数组
                                pushIndex = (pushIndex == limit - 1) ? 0 : pushIndex + 1;
                            }
                            public int pop() {
                                if (size == 0) {
                                    throw new RuntimeException("当前队列为空，无法再添加元素");
                                }
                                size--;
                                int result = arr[popIndex];
                                popIndex = (popIndex == limit - 1) ? 0 : popIndex + 1;
                                return result;
                            }
                            public boolean isEmpty(){
                                return size == 0;
                            }
                            public int getSize(){
                                return this.size;
                            }
                        }

            栈
                数组实现(数组+index)
                    思路
                        一个index就搞定, 来一个值,放index位置,index++, 弹出也是从index弹(如果index小于0,那么就说明为空了)
                    代码实现
                        public class MyStack {
                            private int[] arr;
                            private final int limit;
                            private int optIndex;

                            public MyStack(int limit) {
                                this.limit = limit;
                                this.arr = new int[limit];
                                this.optIndex = 0;
                            }

                            public void push(int value) {
                                if (optIndex == limit) {
                                    // 此时不能再进行添加
                                    System.out.println("当前栈已经满了，无法再进行添加");
                                    return;
                                }
                                arr[optIndex++] = value;
                            }

                            public int pop() {
                                if (optIndex == 0) {
                                    throw new RuntimeException("此时栈为空，没有元素可以弹出");
                                }
                                return arr[--optIndex];
                            }

                            public int size() {
                                return this.optIndex;
                            }

                            public boolean isEmpty() {
                                return this.optIndex == 0;
                            }

                        }
            问题 
                实现一个特殊的栈,在基本功能的基础上,再实现返回栈中最小元素的功能
                    1. pop(),push(),getMin()操作的时间复杂度都是O(1)
                    可以搞两个栈(数据栈+最小值栈)
                        当第一次压入元素时,最小值栈为空,那么就将当前数压入最小值栈,以后有元素再进来的时候,先判断当前元素的值和最小值栈的栈顶元素进行对比,如果比它小,就直接在最小值栈中压入当前元素,如果比栈顶元素大,那么就将栈顶元素再次压入栈顶,数据栈和最小值栈同步增长

                        push()压入的时候,同步压入,复杂度为O(1)
                        pop()弹出的时候,也是同步弹出,复杂度为O(1)
                        getMin()的时候,直接就是最小值栈的栈顶
                    用一个变量去存储最小值貌似是不可以的
                        如果栈中有多个相同的最小值,那如果把最小值弹出去一个,然后再getMin(),这个时候最小值是什么? 怎么取?
                        包括把最小值都弹出去之后,那么这个时候最小值按理讲就应该变成第二小的值,那这个值又怎么办? 
                        所以还是需要一个最小值栈,去存储所有的最小值,然后呢"跟数据栈同步"
                如何使用栈结构实现队列结构?
                    题意
                        给你一个栈结构,里面实现好了的,是个栈,怎么实现的你不用管,问,怎么用栈结构去实现队列
                        两个结构如何互相转换?
                    思路
                        搞两个栈,一个push栈,一个pop栈
                        push栈专门用来压入数据,pop栈专门用来弹出数据
                        如何使用呢?
                            压入的时候直接往push栈中压入,然后呢,push栈中的元素要"倒"到pop栈中,这样pop栈中的顺序就和push不一样了,弹的时候直接从pop中弹出,注意,如果要将push中元素"倒入"到pop中,那么必须一次性全部倒入,不能只倒入一部分,这样的话也是实现不了队列的特性的
                        那如果倒入了一次之后,再进行倒入呢? 
                            弹出的时候,只有当pop为空的时候再去倒入,
                如何使用队列结构实现栈结构?
                    思路
                        搞两个队列,A队列,B队列,数据元素来回跑
                        比如我存1,2,3,4,5 那么存是按照这个顺序,拿的时候肯定要拿5出来,好, 先把这五个元素存到A队列,然后呢,把 1,2,3,4 存入到B队列,A队列中只剩下5,好把5拿出来,这个时候A为空,B不为空(可以作为判断条件),然后又往里面push 6,7 那么肯定都是push到B中的,然后要弹一个出来,弹7,那么B队列中 1,2,3,4,6 都转移到A中去,把7从B中弹出来,依次往复...
                    效率很差
        递归
            任何递归都可以改成非递归,递归比较废空间
            示例
                使用递归获取数组中的最大值
                代码
                    public static int getArrMaxProcess(int[] arr, int left, int right) {
                        if (left == right) {
                            return arr[left];
                        }
                        int middle = left + ((right - left) >> 1);
                        int leftMax = getArrMaxProcess(arr, left, middle);
                        int rightMax = getArrMaxProcess(arr, middle + 1, right);
                        return Math.max(leftMax, rightMax);
                    }
            总体思想
                大问题拆分成多个小问题,但是每个小问题划分的时候规则都是要一样的,然后呢必须要有结束
            Master公式(只适用于子问题规模一致的递归)
                用来分析递归函数的时间复杂度
                示例
                    比如上面递归时间复杂度就可以表示为
                        T(N)=2*T(N/2)+O(1)
                        N就是数据量大小
                        T(N/2) 代表子递归的时间复杂度
                        2*T(N/2) 代表一次函数调用中,子递归发生了多少次
                        O(1) 代表除了递归调用外,其他的操作的时间复杂度
                通用公式
                    T(N)=a*T(N/b)+O(Nⁿ) a,b,n为常数
                    只有子问题规模的递归是一样的时候(T(N/b)),才能用Master公式,如果说子递归一个是N/3,一个是2N/3,那这个就不能使用Master公式来进行预估
                    a是一个函数中调用了多少次自己,跟上面一样
                复杂度判断
                    1. logba<n
                        整个递归的时间复杂度 O(Nⁿ)
                    2. logba>n
                        时间复杂度 O(Nlogba)
                            N的logba次方
                    3. logba=n 
                        时间复杂度 O(Nⁿ * logN)
                    logba和n谁大谁就作为 N 的次方 
                    示例
                        就比如说上面的代码,它的时间复杂度就是: a=2,b=2,n=0 
                            logba=1 n=0 所以 logba>0, 时间复杂度 O(Nlogba)=(N) 也就是说这个方法最终执行结果跟写循环都是一样的,都是O(N)
                        而如果在每次递归的时候都去打印当前这个数组,那么T(N)=2*T(N/2)+O(N) 那么a=2,b=2,n=1,logba=n 所以时间复杂度: O(NlogN)
        Hash表
            增删改查都是常数时间的,只不过常数时间有点大,跟数据量无关
            都是要去查
            非基础类型(基本类型+String)存入HashMap的时候,是不会将整个都放入HashMap的,而是存放对应的内存地址(都是8字节 64位),很省空间
            value相当于是一个HashSet的伴随数据
    归并排序
        时间复杂度
            O(nlogn)
        代码实现
            递归实现
                思路: 先将左侧排好序,然后再将右侧排好序,最后再将排好序的左右两侧进行合并,那自然合并之后的就是一个有序的数组了
                时间复杂度: T(N)=2*T(N/2)+O(N) logba=n 所以时间复杂度: O(n)=nlogn 
                public static void mergeArr(int[] arr, int left, int middle, int right) {
                    int[] help = new int[right - left + 1];
                    int lStart = left;
                    int rStart = middle + 1;
                    int index = 0;
                    while (lStart <= middle && rStart <= right) {
                        help[index++] = arr[lStart] <= arr[rStart] ? arr[lStart++] : arr[rStart++];
                    }
                    // 走到这里就说明至少有一个已经跳出了
                    // 判断左侧是否越界
                    while (lStart <= middle) {
                        help[index++] = arr[lStart++];
                    }
                    // 判断右侧是否越界
                    while (rStart <= right) {
                        help[index++] = arr[rStart++];
                    }
                    // 排序完成,help就是个有序数组
                    // 将help中的值设置进入arr中
                    for (int i = 0; i < help.length; i++) {
                        arr[left + i] = help[i];
                    }
                }
                public static void mergeSortWithRecursion(int[] arr, int left, int right) {
                    if (arr == null || arr.length < 2) {
                        return;
                    }
                    if (left == right) {
                        return;
                    }
                    int middle = left + ((right - left) >> 1);
                    // 对左边进行排序
                    mergeSortWithRecursion(arr, left, middle);
                    // 对右边进行排序
                    mergeSortWithRecursion(arr, middle + 1, right);
                    // 走到这里说明两边都已经排序完成,然后进行合并
                    mergeArr(arr, left, middle, right);
                }
            迭代实现
                思路 
                    步长从1开始倍数增长,每次left都从0开始,按照步长进行划分两段区域(找到对应的middle(当前两段中间的那个位置---第一段的最后一个位置),以及right(就是当前两段的最后一个位置)),然后对这两段进行合并
                    然后呢,left变成right+1,又开始计算,就是每一个步长下,有很多个两段两段的,这些两段要从头开始往后算,把他们一一进行合并
                    当然了,步长从1开始,保证了以后步长增大到一定的值之后,每一个段内都是有序的,这样的话两个段就可以直接进行合并
                    
                    要考虑算出的middle越界的情况
                public static void mergeSortWithIteration(int[] arr) {
                    if (arr == null || arr.length < 2) {
                        return;
                    }
                    
                    // 设置初始步长,默认为1开始,1--->2--->4--->8
                    int step = 1;
                    int length = arr.length;
                    // 步长*2 递增, 这样时间复杂度就为 logn
                    while (step <= length) {
                        // 每次当步长改变,然后left都从0开始
                        int left = 0;
                        // 一组一组进行合并比较
                        while (left < length) {
                            // 先计算出左组末尾的值,相当于是左右组的中间位置
                            int middle = left + step - 1;
                            if (middle >= length) {
                                break;
                            }
                            // 然后计算出右组末尾的值,但是这个值可能会导致溢出/越界,所以需要判断,如果越界,那么就取数组最后一个值
                            int right = Math.min((middle + step), (length - 1));
                            // 然后那这个时候,左组和右组,以及中间位置都搞出来了,那么就进行合并
                            mergeArr(arr, left, middle, right);
                            // 合并之后,left要移动到rightEnd+1的位置
                            left = right + 1;
                        }
                        // 溢出判断
                        if (step > length / 2) {
                            break;
                        }
                        // 乘以2
                        step = step << 1;
                    }
                }
        问题
            1. 小和问题
                题意
                    比如给一个数组: [6,3,2,1,6,7], 那么找到每一个元素左侧的比他小的值进行相加,最后将所有元素的小和都加起来,得到的值
                        比如第一个6,左边比6小的和为0, 3,2,1 左边都没有比他们小的,所以每个都是0, 第二个6,左边比他小的就是3,2,1,那么小和为6,而对于7 左边比它小的 6,3,2,1,6 小和就是18, 那么6+18=24, 这个就是最终的值
                解决方案
                    1. O(N²)---不好
                    1. O(nlogn)
                        递归+for(n)循环找出每一个比当前小的数
                            public static int littleSum(int[] arr, int left, int right) {
                                if (left == right) {
                                    int sum = 0;
                                    // 遍历 for循环找到当前数左侧比他小的和
                                    for (int i = 0; i < left; i++) {
                                        if (arr[i] < arr[left]) {
                                            sum += arr[i];
                                        }
                                    }
                                    return sum;
                                }
                                int middle = left + ((right - left) >> 1);
                                // 找到左侧小和
                                int leftLittleSum = littleSum(arr, left, middle);
                                // 找到右侧小和
                                int rightLittleSum = littleSum(arr, middle + 1, right);
                                // 左右两侧相加
                                return leftLittleSum + rightLittleSum;
                            }
    荷兰国旗问题
        题意
            给定一个数组,然后给一个值x,小于x的放在数组的左边,大于x的整体放在数组右边,等于x的放在中间
            要求不使用额外辅助数组,并且时间复杂度为O(n)
        1. 小于x的放左边,大于x的放右边
            思路
                搞一个<=区域,从-1开始,然后呢依次往后推,如果当前数<=目标数x,那么当前数和<=区域的后一个数进行交换,然后<=区域往后扩1,如果当前数>目标数x,那么就直接往后移动一位,不管他,直到再次遇到当前数<=(<=区域最后一个数)

                这个就是,搞一个推推(<=区域),一次一次往后推,比目标数x小的放进来(当前数和推推后面一个数交换,然后推推往前推),比目标数大我就直接往后走,不管他
        2. 小于x的放左边,等于x的放中间,大于x的放右边 
            三个区域可以无序,但是必须要分成左中右
            思路
                搞一个<=区域,一个>=区域,<=区域从-1开始,>=区域从length+1开始
                    当前数<目标数x
                        当前数和<=区域后一个数交换,然后<=区域往后推一个将这个交换过后的小于目标值x的数括进去
                    当前数=目标数x
                        直接往后移动一位,不用管
                    当前数>目标数x
                        当前数和>=区域前的一个数交换,然后>=区域往前推一个将这个大于目标值的x括进去,然后当前数位置不动,因为可能换过来的数比目标值x小,就需要进行再次比较,那为啥上面<目标数的时候是直接往后移动了呢?因为是从左往右扫的,而<=区域也是从左往右括的,<的时候走到那里,前面的数都已经扫过了,所以直接往后移动
                    当前数的下表和>=域的下表重合时,整个流程走完
            代码实现
                返回和x相等的数的下标范围(开始下标+结束下标)
                public static int[] netherLandsFlag(int[] arr, int left, int right) {
                    if (left > right) {
                        // 那还比个p,数据不合格,直接退出返回
                        return new int[]{-1, -1};
                    }
                    if (left == right) {
                        // 都是同一个下标嘛
                        return new int[]{left, right};
                    }

                    // 小区域下标从-1开始,如果定义left,那就是从left-1开始
                    int lessIndex = left - 1;
                    // 大区域下标从right开始,right最开始只作为目标数,不进行考虑,后面要跟大区域的第一个进行交换
                    int moreIndex = right;

                    // 设置目标值默认为 最右边的
                    int target = arr[right];

                    // 指针从left开始从左往右骚扫
                    int ref = left;

                    // 当扫描指针扫到大区域时,此时就可以停止了,为啥呢? 扫到大区域了嘛,说明前面的都已经看过了,改该处理的都已经处理了,剩下没扫的就都是大区域的了,不用扫了呢
                    while (ref < moreIndex) {
                        if (arr[ref] < target) {
                            // 当前ref的值和小区域后一个交换,指针后移,小区域后移
                            arrSwap(arr, ref++, ++lessIndex);
                        } else if (arr[ref] > target) {
                            // 当前ref的值和大区域前一个值交换,大区域后移,当前指针不动,因为换过来的元素可能比target小,所以还需要进行下次判断
                            arrSwap(arr, ref, --moreIndex);
                        } else {
                            // 直接指针后移
                            ref++;
                        }
                    }
                    // 一套搞完之后,此时ref=moreIndex,但是因为最后一位 right就是目标值,它不是大于目标值的,所以要将他和大区域的第一位交换
                    arrSwap(arr, right, moreIndex);

                    System.out.println("搞完之后的数组:" + Arrays.toString(arr));
                    int firstEqualIndex = lessIndex + 1;
                    int lastEqualIndex = moreIndex;
                    return new int[]{firstEqualIndex, lastEqualIndex};
                }

                public static void arrSwap(int[] arr, int num1, int num2) {
                    int temp = arr[num1];
                    arr[num1] = arr[num2];
                    arr[num2] = temp;
                }
    快速排序
        快排 1.0 
            思路
                结合上面的荷兰国旗问题, 通过递归,让每一段,都使得最右边作为最小值,然后呢比他小的放在左侧,比他大的放在右侧,相等的放在中间,那到最后就有序了
        快排 2.0
            思路
                在 1.0 的基础上, 返回和x相等的数的下标,可能有一批数和目标值x相等,那么拿到这两个下标之后(参考上面荷兰国旗代码),那就可以进一步过滤掉一批数据,上面 1.0 只是拿到一个等于x的下标
            代码实现
                public static void quickSort2(int[] arr) {
                    if (arr == null || arr.length < 2) {
                        return;
                    }
                    process2(arr, 0, arr.length - 1);
                }

                public static void process2(int[] arr, int left, int right) {
                    if (left >= right) {
                        return;
                    }
                    int[] equalArr = netherLandsFlag(arr, left, right);
                    // 左侧
                    process2(arr, left, equalArr[0] - 1);
                    // 右侧
                    process2(arr, equalArr[1] + 1, right);
                }
            总体思想
                就是保证每一段上,小的在左边,相等的放中间,大的放右边
                第一次分段之后,在对右边的段继续分,此时右边的段肯定全部都比中间的小嘛,然后左边的段又继续分,左边肯定比中间的大嘛,以此类推递归去分,分到最后两个的时候那肯定就可以保证有序了嘛
        随机快排 3.0 --- 真正的快排
            1.0 和 2.0 的时间复杂度都是O(n²)
                最坏的情况嘛, 比如就是1234567, 这种第一次拿7作为目标值,然后第二次拿着6作为目标值,以此类推,最高项阶就是n²
            思路
                在left和right中间"随机选择一个数"作为"目标值",而不是始终使用最右侧的那个值
            时间复杂度
                O(nlogn) 不是说忽略了最差的情况,而是最差的情况成了概率事件,最差情况出现的时候也是nlogn, 平均复杂度是O(nlogn)
            额外空间复杂度
                O(logn)
                最差情况就是每个目标值/划分值 都需要记录下来,那额外空间复杂度就是O(n)
            解决
                为了避免上述情况产生,我们在数组中随机选择一个数让他和最后一个位置的数交换,那么就可以某种程序上避免这个问题的发生,但是也是个概率问题,不是说每次都能避免,只是让他成为一个概率问题
            代码实现
                递归版本
                    public static void process2(int[] arr, int left, int right) {
                        if (left >= right) {
                            return;
                        }
                        swap(arr,left+(int)(Math.random()*(right-left+1)),right);
                        int[] equalArr = netherLandsFlag(arr, left, right);
                        // 左侧
                        process2(arr, left, equalArr[0] - 1);
                        // 右侧
                        process2(arr, equalArr[1] + 1, right);
                    }

                    或者是直接,诶使用left和right中间那个位置的元素作为目标值进行划分
    堆结构+堆排序
        概述
            堆结构就是用数组实现的"完全二叉树"结构
            完全二叉树中如果每颗子树的最大值都在顶部就是大根堆
            完全二叉树中如果每颗子树的最小值都在顶部就是小根堆
            堆结构的heapinsert和heapify操作
            堆结构的增大和减少
            "优先级队列"结构,就是堆结构

            优先级队列底层就是用堆实现的
        完全二叉树 
            概述
                如果一棵树是满的,它就是一颗完全二叉树,或者在变满的路上,从"左到右依次变满",这也算是完全二叉树
                空树是不是?
                    是,人为规定
                只有一个节点的二叉树是不是?
                    是,这一层上是满的
                  O       O
                 /   是    \   不是,不能跳过左边的,这样就不是完全二叉树了
                O           O 

                上面的层一定是满的,如果有不满的层,那一定是最后一层,而且是"从左到右"依次变满
            数组
                从0出发的一个连续的数组,可以被生成一颗完全二叉树(就是从0开始依次往下放)

                规律
                    对于数组中下标为i的元素
                        左孩子的下标: 2*i+1
                        右孩子的下标: 2*i+2
                        父节点的下标: (i-1)/2
        堆一定是完全二叉树
            大根堆: 在一棵完全二叉树中,"每一颗子树"的头结点是当前子树的最大值
            小根堆: 在一棵完全二叉树中,"每一颗子树"的头结点是当前子树的最小值

            但凡有一颗子树违规,整个子树就直接不算堆
        过程原理(就两种操作)

            先初始化一个数,把他想象成对应的完全二叉树,然后搞一个变量记录当前堆的大小heapsize
            heapInsert(添加值)
                思路
                    按照顺序加进来之后,注意哦,实际是添加到数组上的哦,只是想象出来一颗完全二叉树,然后添加元素的时候加到对应的位置之后,根据数组转二叉树的特点,父节点在(i-1)/2的位置上,那么新增一个元素的时候就要去跟"父节点"对应下标的位置进行对比,根据大根堆/小根堆判断是否需要替换,一直要比对到根节点

                    就是依次"跟父节点进行对比",看看是否需要上位,保证在这个范围内,是个大/小根堆

                代码 
                    迭代方式
                        public static void heapInsert(int[] arr, int index) {
                            while (arr[index] > arr[(index - 1) / 2]) {
                                // 交换
                                swap(arr, index, (index - 1) / 2);
                                index = (index - 1) / 2;
                            }
                        }
                    递归方式
                        public static void heapInsertRecursion(int[] arr, int index) {
                            if (arr[index] <= arr[(index - 1) / 2]) {
                                return;
                            }
                            // swap
                            swap(arr, index, (index - 1) / 2);
                            heapInsertRecursion(arr, (index - 1) / 2);
                        }
            heapify(下沉)---获取最大/小值+删除它,还要保持堆的形态
                思路
                    先搞一个临时变量把最大值(arr[0])记录下来,然后呢,将此时的arr[heapsize]就是当前数组中最后一个有效值,跟arr[0]替换,heapsize-1,逻辑删除,然后那这个时候可能新上位的元素不是最大值,所以他要跟自己的左右孩子(arr[2*i+1],arr[2*i+2])中较大的那个对比,如果说这个较大值比他大,那就要把它换下去,较大的换上来(因为要保证子树的根节点比其他大,所以换的是较大的上来,就是取父左右三个中的最大值,如果是自己,那就不用动了),以此类推,换下去之后再进行对比,直到最后,有heapsize管着,判断左右孩子是否超过heapsize,有一个超过了那就说明没有这个孩子,

                    就是,把最后一个放到堆顶,然后这个元素根据情况"下沉"(跟左右孩子中"较大的"那个进行对比)
                代码实现
                    /**
                    * 让指定元素进行下沉
                    * @param arr      目标数组
                    * @param index    要下沉的元素下标
                    * @param heapSize 堆大小
                    * @return
                    */
                    public static void heapify(int[] arr, int index, int heapSize) {
                        // 根据下沉元素的下标获取左子节点
                        int leftChildIndex = 2 * index + 1;
                        // 判断左子节点是否越界,因为如果左子节点越界,右子节点肯定也越界,那就说明当前index位置没有子节点了
                        while (leftChildIndex < heapSize) {
                            // 没有越界
                            int rightChildIndex = leftChildIndex + 1;
                            // 取出左右子节点中较大的一个下标,同时判断右子节点是否存在,如果不存在,那就取左子节点下标
                            int largerIndex = ((rightChildIndex < heapSize) && arr[rightChildIndex] > arr[leftChildIndex]) ? rightChildIndex : leftChildIndex;
                            // 再拿着较大值跟当前父节点进行对比
                            int largestIndex = (arr[largerIndex] > arr[index]) ? largerIndex : index;
                            // 如果说largestIndex==当前的index,说明当前的index就已经是当前所在子树的顶端,那么就不用再往下走了
                            if (largestIndex == index) {
                                break;
                            }
                            // 走到这里,说明largest和index不相等,那么就进行交换
                            swap(arr, index, largestIndex);
                            // 交换完成之后呢,index就变成交换之后的那个下标
                            index = largestIndex;
                            leftChildIndex = 2 * index + 1;
                        }
                    }
            PriorityQueue 优先级队列底层就是堆实现的,默认是小根堆
                可以接受重复值
            时间复杂度
                如果数组中已经存在n个元素
                heapInsert() 和 heapify() 的时间复杂度都是"logn"
                    因为算下来,完全二叉树的高度就是logn,所以它去insert或者下沉的时候,走的是按照这个高度,一层走一次,最多每层都走一次嘛
        一个堆结构,其中有一个下标的值已经变了,但是不知道这个值是变大了或者变小了,那么可能堆的结构就变了,那怎么搞才能继续让整个结构保持是一个堆的形态呢?---在加强堆中用
            1. heapInsert(arr,index);
            2. heapify(arr,index,heapSize);
            执行上面两步,index就是改变的下标值,那为什么可以这样呢?
                1. heapInsert() 就是将当前的值往上移动,保证了从这个节点开始,上面的元素是堆结构
                2. heapify() 在heapInsert()之后,换下来的值,然后去进行heapify()保证它往下的结构是一个堆结构

                执行顺序无所谓啊,反正让他一次heapInsert()一次heapify()就行,本质就是"分别保证上半部分和下半部分的堆结构",那整个结构就自然是堆结构了

            如果变化之后的值比之前大,那么就"可能会往上走",走了之后heapify()就不会发生,因为上面的值换下来肯定比下面的大
            如果比之前小,那么就不会往上走,"可能会往下走",因为下面的值比当前的值小
            两个只会发生一个
    堆排序
        思路(大根堆---升序)
            1. 要先把整个数组调成一个大根堆
            2. 既然已经是个大根堆了,那么heapSize就是数组的长度,而且第一个位置(索引为0)的值肯定是最大值,好,把这个值和最后一个值进行交换,那么第一个值就不是最大值了,heapSize--,从0~(N-1)的位置,我们再让他进行heapify,那么这个heapify()的时间复杂度就是logn,以此类推,heapSize--,0~N-2/N-3... 直到heapSize==0的时候,结束
        代码实现
            public static void heapSort(int[] arr) {
                if (arr == null || arr.length < 2) {
                    return;
                }
                // 先将arr构造成大根堆,使用heapInsert()就可以
                for (int i = 0; i < arr.length; i++) {
                    heapInsert(arr, i);
                    //heapInsertRecursion(arr, i);
                }
                // 此时已经构造成了大根堆
                int heapSize = arr.length;
                while (heapSize > 0) {
                    // 让0位置的值(0~heapSize上的最大值)和最后一个值交换
                    swap(arr, 0, --heapSize);
                    // 交换之后让0位置的值下沉
                    heapify(arr, 0, heapSize);
                }
            }
        时间复杂度(nlogn)
            heapInsert的时候,他是时间复杂度是动态变化的
                就是不是一开始就是logn,因为新增第一个元素,那就是log1,新增第二个那就是log2,以此类推,知道最后一个元素的时候才是真正的logn,所以就是log1+log2+log3+...logn
            
            但是如果数据量变大(扩倍),变成2N,那么前N个数的就是nlogn, 从(N+1)~2N那就是logN+1...log2N,那么实际上也就是nlogn+logn+1..log2n,那复杂度最后不也是nlogn?

            构建堆的时间复杂度
                上边那种方式是O(nlogn)--->从上往下建堆
                S = n - log(n) -1
                O(n)
            排序重建堆的时间复杂度☆---再怎么都是O(nlogn)
                O(nlogn)
            所以总的时间复杂度: O(nlogn)+O(nlogn)=O(logn)
        建堆方法
            1. 上面那种方法,从上往下,时间复杂度是O(nlogn)
            2. 从下往上,时间复杂度O(n)
                前提
                    前提是拿到这些数之后,也就是拿到数组之后,这里是排序,肯定可以嘛
                    如果人家用户只是一个一个给你,那就没办法,只能从上往下了
                思路
                    从叶子节点开始依次往下heapify(),然后倒数第二层开始往下heapify(),倒数第三层往下heapify()...
                    那么时间复杂度就是,叶子节点往下看,叶子节点个数: N/2, 倒数第二层个数是N/4,往下看两层,那就是N/4 * 2, 倒数第三层个数是N/8,往下看三层,那就是N/8 * 3...
                    那么总共就是T(N)=N/2*1+N/4 * 2+N/8 * 3...  最终趋近于O(n)

                那为啥从下往上就是O(n)呢? 因为大量的节点是在最开始,层数很小,少量的节点在最后,层数很高
                当从上往下的时候,少量的节点在最开始,层数很小,大量的节点在最后,层数很高,数据大+层数高 那肯定复杂度就上去了

                代码 
                    for(int i=arr.length-1;i>=0;i--){
                        heapify(arr,i,arr.length);
                    }
            所以说,堆排序最快的方式还是 只含有heapify()来进行排序,不需要heapInsert()
        问题 
            已知一个几乎有序的数组,几乎有序是指,如果把数组排好顺序的话,每个元素移动的距离一定不超过k,并且k相对于数组长度来说是比较小的,请选择一个合适的排序策略,对这个数组进行排序
                可以搞一个容量大小为(k+1)的小根堆/优先级队列,在0~k的范围上,将这些元素存入小根堆中,然后pop()出一个元素,这个元素就肯定是0~k的最小值,然后因为元素移动的距离不超过k,所以弹出这个元素就可以直接放到0位置,然后后面同理,将1~k+1的值都放入小根堆中,弹出,然后弹出的值放到下标为1的位置...
                时间复杂度 O(nlogk) 
    加强堆
        概述
            有的时候系统提供的堆,比如优先级队列,无法满足特定的功能,它只能实现一部分基础的,比如弹出啊,获取堆顶元素啊之类的...
            而有时候,对于一些特定场合,比如堆中的元素指向的值发生了变动,系统自带的堆无法实现自行进行调节,改了就改了,那么可能这个时候堆的特性无法再继续维护

            对于堆中的每一个元素,它也没有一张反向索引表去记录哪个值存在哪个索引下标位置
        代码
            public class HeapGreater<T> {

                //用于保存数据的数组,堆底层就是数组
                private ArrayList<T> heap;

                //反向索引表(值,索引)
                private HashMap<T, Integer> indexMap;

                //堆的大小
                private int heapSize;

                //比较器
                private Comparator<T> comparator;
                ...
                public void resign(T value) {
                    heapInsert(indexMap.get(value));
                    heapify(indexMap.get(value));

                }
                public void swap(int i, int j) {

                    T obj1 = this.heap.get(i);
                    T obj2 = this.heap.get(j);

                    // 数组元素交换
                    this.heap.set(i, obj2);
                    this.heap.set(j, obj1);

                    // 反向索引表同步更新
                    indexMap.put(obj1, j);
                    indexMap.put(obj2, i);
                }
            }
    前缀树(Prefix Tree/Trie树)---"多叉树"
        应用场景
            比如现在我有一个字符串数组,我想把这其中所有的字符串都加入到一颗树中去,怎么加呢,当然可以直接暴力加入,但是很deer
        思路
            ["abc","abd"]
            过程
                这个时候,可以搞空的头节点,拿到第一个元素,第一个字符是a,然后看,欸之前没有存过,那么把a放在"路"上,形成一个新的子节点,然后b,发现这个子节点下也没有出现过b,那么就新开一条"路",将b放在路上,然后也随之新建一个子节点,以此类推... 

                到第二个元素,发现开头是a,好,之前出现过a,那么就直接找到a往下走,然后b,发现b也出现过,那么又走,到d,欸发现之前b后面只出现过c,d没出现过,那就新开一条路+节点,将d放在路上

            每次一个新的元素都从头节点开始出发,字符放在了"路"上,"多叉树"
        升级版(会多一些数据项)
            本来每个节点我是不放值的,节点就相当于是空的,字符是放在路上的,那么现在我要增加一些数据

            每个节点封装两个值
                p(pass): 总共有多少个字符经过当前节点
                e(end): 有多少个节点在这里结束
            每次经过一个节点,p就+1,当一个字符串结束的时候,对应末尾字符的e+1,每新增一个数组中的元素时,头节点的p+1,那么也就是说根据头节点就可以知道当前数组总共有多少个元素

            升级版有啥用
                如果我一个字符串数组,我想知道里面abc出现了几次
                    那么分别根据a b c去找路,没找到就是没有,找到c之后,e的值是多少那就是出现了几次

                        如果正常来,好,遍历这个数组,然后搞个计数器,时间复杂度是O(n),而现在是字符串长度是多少,那就是查找多少次O(str.length)
                        或者使用Hash表
                        将每个元素都存入Hash表,然后在Hash表中维护他们出现的个数,这样也可以,但是时间复杂度就上去了,况且Hash表也不支持"前缀查询" 
                我想知道以ab开头/作为前缀的字符串个数
                    直接根据a b去找,一下子就找到了,看最后一个元素b的那个p,如果没有以这个开头的就返回嘛
            Hash表的增删改查时间复杂度都是O(1)
                仅仅适用于"忽略掉单样本大小"的情况,就是跟样本大小本身没关系的时候才是O(1),比如说整数这种
                    因为整数嘛,直接拿过来算个Hash值,然后放到数组里,存进去嘛,那就是O(1)
                对于像"字符串",他的时间复杂度就不是O(1),因为字符串比较特殊,它去算这个Hash值的时候,是要把字符串遍历一遍然才能算出一个Hash值,那时间复杂度即使O(str.length)

                所以一般对于简单的数据类型,Hash表的CRUD时间复杂度都是O(1),对于字符串这种复杂的,那就不是了
                那对象呢? 对象也是O(1),因为默认是存的对象的地址嘛,那如果自己实现hashcode()那就另说了
                    所以也就是为什么有时候实现equals()方法也必须实现hashcode()方法,两个对象在你的逻辑里应该是相等的,但是地址肯定不同,这个时候要自己实现hashcode()定义他们的逻辑

                所以将字符串数组中元素存入Hash表,假定字符串数组总共有M个"字符",那时间复杂度就是O(M),因为要把所有的元素都要扫一遍

        代码实现
            public class Node {
                public int pass;
                public int end;
                public Node[] nexts;

                public Node() {
                    this.pass = 0;
                    this.end = 0;
                    this.nexts = new Node[2];
                }
            }
            public class Trie {
                // 根节点
                public Node root;
                public Trie() {
                    this.root = new Node();
                }
                ...CRUD
            }
    不基于比较的排序
        概述
            桶排序,就是"容器"
            不基于比较的排序,一定得要求数据范围特殊,它的扩展性没有"基于比较的排序"好
        时间复杂度
            极限: O(n)
            不基于比较的排序: O(nlogn)是极限
        计数排序(countSort)---O(n)
            问题
                比如说我现在一个数组,数组中的每一个元素都代表员工的年龄,好那把这个数组从小到大排序出来
            思路
                因为员工年龄,这个数据的大小最终是有限制的,不是说规模啊,就是说单个元素的取值范围,顶多200嘛,好,那我就搞一个"统计数组",长度就是200,然后呢,遍历一遍原数组,O(n),然后将数组里面的元素,多少岁的年龄,我就放在统计数组的哪个下标,然后值就是这个年龄的人出现了多少次,这一套搞完之后,再通过"统计数组"遍历一遍,什么年龄的有几个人,按照顺序排列出来就行,这里也是O(n)
                    为什么这里也是O(n)呢,如果50个员工全都是同岁,那么生成排序数组的时候,不就200*50了吗? 但是前面那个200是数据的最大取值范围,是个常量,不是n,跟数组的长度50没关系,顶多就是200n嘛,所以还是O(n)
            应用
                应用数据状况受限的情况
            思想是"桶排序"
                每一个年龄就是一个桶,这些桶是有顺序的,归根结底是"容器"的思想
        基数排序
            思想也是桶排序,桶:就是容器
            数据约束
                非负的,十进制表示的数
            思想
                比如给一个非负的,十进制的数组,让排序
                先获取最大值,看看最大值是多少位,比如说3位,那么不足百位的,填充0,准备十个"桶"/"队列"(0~9),要进行三轮操作
                    第一轮,遍历数组,将他们的个位拿出来依次放进对应的桶里,搞完之后,O(n)嘛,从第0号桶开始,将这些数按照"先进先出"的顺序拿出来,重新得到一个数组,这一轮主要是对个位进行排序,只是对个位,而不是对整体
                    第二轮,一样,遍历数组,将他们的十位拿出来,放进对应的桶(此时刚开始桶是空的),搞完之后,O(n)嘛,从第0号桶开始,又将这些数按照"先进先出"的顺序拿出来,又得到一个新的数组,这一轮主要是对十位进行排序,并且保证了十位相同的情况下,个位递增的顺序
                    第三轮,一样,遍历数组,拿出他们的百位,也是放入到十个桶里,然后又出来,保证了整个数组的有序性
            代码实现(参考git代码)
                /**
                * 获取数组中最大的位数
                *
                * @param arr
                * @return
                */
                public static int getMaxDigit(int[] arr) {
                    int max = Integer.MIN_VALUE;
                    for (int num : arr) {
                        max = Math.max(max, num);
                    }
                    int maxDigit = 0;
                    while (max != 0) {
                        maxDigit++;
                        max /= 10;
                    }
                    System.out.println("数组中最大位是：" + maxDigit);
                    return maxDigit;
                }

                /**
                * 获取第bit位的树是多少
                *
                * @param num
                * @param bit
                */
                public static int getDigit(int num, int bit) {
                    int result = -1;
                    for (int i = 0; i < bit; i++) {
                        result = num % 10;
                        num /= 10;
                    }
                    return result;
                }

                /**
                * 基数排序
                */
                public static void radixSort(int[] arr) {
                    if (arr == null || arr.length < 2) {
                        return;
                    }
                    // 先获取最大的位数
                    int maxDigit = getMaxDigit(arr);
                    radixSort(arr, 0, arr.length - 1, maxDigit);
                }

                private static void radixSort(int[] arr, int left, int right, int maxDigit) {
                    int[] help = new int[arr.length];
                    for (int i = 1; i <= maxDigit; i++) {
                        // 用来记录每个位出现了多少次
                        int[] count = new int[10];
                        for (int j = 0; j < arr.length; j++) {
                            // 获取第i位的值，存入count数组中
                            int digit = getDigit(arr[j], i);
                            count[digit]++;
                        }
                        // count--->count' 用来存储当前位<=digit的元素个数
                        for (int j = 1; j < count.length; j++) {
                            count[j] += count[j - 1];
                        }

                        // 原数组从右往左开始走，根据 count' 数组，填充help数组
                        for (int j = arr.length - 1; j >= 0; j--) {
                            int digit = getDigit(arr[j], i);
                            // 根据digit位数，从 count' 中获取<=digit的个数有多少
                            // 然后假如说是6个，那么说明数组中这个位上<=digit的元素有6个，自然是把它放到help数组的第6个位置(下表：6-1)
                            // 放好之后，要把 count' 中的这个6减1，变成5，说明还有5个元素<=当前这个digit,后来的元素，就不会对第六个位置冲突
                            int helpIndex = count[digit] - 1;
                            help[helpIndex] = arr[j];
                            // 用了一个之后，那么<=当前位的值就-1
                            count[digit]--;
                        }
                        // 用help数组覆盖原数组
                        for (int j = 0; j < arr.length; j++) {
                            arr[j] = help[j];
                        }
                    }
                }
        计数排序和基数排序
            一般来讲,计数排序要求: 样本是整数,且范围比较窄
            一般来讲,基数排序要求: 样本是10进制的正整数
            一旦要求有变动,改动起来会比较麻烦
    排序算法的稳定性
        概述
            稳定性不是指的是 时间复杂度 忽快忽慢,时间复杂度不会忽快忽慢,都是以最差情况估计的嘛,不会变啊

            稳定性: "相同大小的样本"在排序之后会不会改变相对次序
                比如: 没排序之前数组中有两个1,那么排序之后,之前的第一个1还是不是新数组的第一个1,之前的第2个1是不是新数组的第二个1
                如果排序之后还能保持原来的相对次序,那么就是有稳定性,如果做不到,那么就没有稳定性
        稳定性的作用
            如果是基础类型
                比如整数啊,double之类的小数啊,那"稳定性没有作用",因为基础类型关注的是本身的值,跟顺序不顺序无关
            如果是引用类型
                那么稳定性算法就比较大,比如在第一次排序之后进行第二次排序,第二次排序的结果在同等的条件下/内部,他的第一次排序的属性依旧是稳定的
        算法稳定性
            有的算法可以通过代码优化实现稳定性,而有的算法始终不能

            选择排序
                做不到稳定性,思想是把最小的放到最前面,那这样必然会导致原数组中的相对次序会发生改变
                    比如: 5 5 5 5 3 5   那排序之后 第一个5变成了第4个4 跟之前不一样 不稳定
            "冒泡排序"
                可以做到稳定性, 两个不一样的进行交换嘛,关键在于如何处理相等的时候,相等的时候不交换不就得了
            "插入排序"
                也可以做到稳定性,相等的时候不让它往前换就得了
            "归并排序"
                也可以做到稳定性
            快速排序
                稳定不了,划分值partition做不到稳定
            堆排序
                不稳定,生成大根堆的时候就不稳定了,把之前人家的次序给破坏了
                    比如 数组[3,3,3,3,3,3,5],5要上浮,那是将它的父元素换下来的,那父元素那个位置的3就维持不了,把父元素换到了自己的位置,那肯定维持不了嘛
            "计数排序"/"基数排序"/"桶排序"
                稳定
    排序总结
        基于比较的排序时间复杂度就两种 O(N²) 或 O(NlogN)
        不基于比较的排序时间复杂度就是O(N),但是限制比较多,额外空间就却决于桶的空间,有稳定性的

        对比表
            排序算法        时间复杂度      额外空间复杂度      稳定性

            选择排序          O(N²)             O(1)            ×
            冒泡排序          O(N²)             O(1)            √
            插入排序          O(N²)             O(1)            √
            希尔排序          O(N1.3~2)         O(1)            ×
            归并排序          O(NlogN)          O(N)            √
            快速排序          O(NlogN)          O(logN)         ×
            堆排序            O(NlogN)          O(1)            ×
            -----------------------------------------------------
            计数排序          O(N)              O(M)            √
            基数排序          O(N)              O(M)            √

            M取决于数据范围
        总结
            1. 不基于比较的排序,对样本数据有严格的要求,不易改写
            2. 基于比较的排序,只要规定好两个样本怎么比对大小就可以直接服用
            3. 基于比较的排序,时间复杂度的极限是O(NlogN)
            4. 时间复杂度O(NlogN),额外空间复杂度低于O(N),且基于比较的排序是不存在的
            5. 为了绝对的速度选"快排",为了省空间选"堆排序",为了"稳定"选"归并"
        坑/废话
            1. 有的帖子说可以将归并排序的额外空间复杂度变成O(1),使用"归并排序内部缓存法",但是这种将变得不再稳定
                那为啥不直接用"堆排序"呢?
            2. "原地归并排序",会让时间复杂度变成O(N²)
            3. "快速排序稳定性改进","01 stable sort",但是会对样本数据有要求
                那为啥不用桶排序呢
            问 
                整型数组中,请把奇数放在数组左边,偶数放在数组右边,要求所有奇数之间的原始的相对次序不变,所有偶数之间原始相对次序不变(稳定),能不能在时间复杂度位O(N),额外空间复杂度为O(1)的情况下做到?
                
                不能,这种分区的问题,人家快排都做不到,这个很明显无法实现,如果能做到,人家快排作者是傻子想不到?
        工程上对排序的改进
            考虑两个方向
                1. 稳定性
                    Java中的Arrays.sort()方法
                        底层实现: 
                            如果传入的是基础类型,那么就会选择快速排序(基础类型对稳定性没啥要求)
                            而如果是非基础类型,那就会选择归并排序,他不知道你要不要用稳定性,但是得给你保证稳定性
                2. 充分利用O(NlogN)和O(N²)排序各自的优势
                    比如有的语言实现快排的时候,当数据量的范围在60/47之间的时候,采用"插入排序",而不是直接使用快排
                    虽然说快排的时间复杂度比较好,插入排序的时间复杂度比较慢,但是在数据量很小的情况时,插入排序的常数项小,比较有优势,60是实验出来的
    链表的相关算法
        快慢指针
        笔试
            在没有要求的情况下,能用容器就用容器,一切为了时间复杂度
        面试
            既要考虑时间复杂度,也要考虑空间复杂度,用了容器就破功,放到容器里就比较容器了
        常用技巧
            用容器(哈希表,数组...)
        问题
            1. 判断链表是不是回文链表
                1. 用容器
                    可以用栈结构,先遍历一遍将里面的数据全部压入到栈中,然后再遍历一遍,遍历的时候同时也从栈中弹出元素,如果它是个回文链表,那么每一次的值都和栈匹配的上,如果不是,那就会出现匹配不上的情况
                    
                    也可以转成数组再那啥
                2. 不用容器,用快慢指针
                    链表反转
            2. 判断链表是否有环,如果有,就返回第一个入环元素
                1. 用容器
                    遍历链表,搞一个HashSet,判断HashSet中存不存在,如果存在了,那就是有环,一直不存在直到为null就是无环
                2. 快慢指针
                    一个快指针,一个慢指针,快指针一次走两步,慢指针一次走一步
                    遍历链表,如果快指针没走到null,并且和慢指针相遇了,那么说明"有环",如果快指针走到了null,那说明没环
                    然后当两者相遇,此时,快指针回到Head节点,然后一步一步走,慢指针停在相遇的位置,也是一步一步走,当他们再次相遇的时候,就是"入环节点"(这是个结论相当于)
                代码
            3. 给定两个可能有环也可能无环的单链表,头节点head1和head2,请实现一个函数,如果两个链表相交,请返回相交的第一个节点,如果不相交,返回null
                要求 
                    如果两个链表长度之和为N,时间复杂度请达到O(N),额外空间复杂度请达到O(1)
                解决方案
                    如果两个链表都不是环形链表
                        先将第一个遍历完成,获取到它的尾节点 end1 和长度length1,再遍历第二个节点,获取end2和长度length2,判断end1和end2是否为同一个节点
                            如果不是,那就说明这两不相交,因为如果相交的话,那么尾节点必定重合,不会存在一个长一个短的情况
                                如果一个长一个短,那么短的链表的尾节点必定指向null,而不可能再是单链表的结构,两个指针指出去了
                            如果是,那么就用较长的那条链表,先走"差值"步,然后两个再分别各自一步走,直到两个相等的时候,就是相交的第一个节点
                                比如链表1的长度是100,链表2的长度是80,那就让链表1先走20步,然后两个链表再分别一步一步走,直至重合
                    如果一个有环,一个无环,他两不可能相交
                        为啥呢? 那个无环的,肯定最后一个节点指向null吧? 但是如果和一个有环的相交了,它怎么指向null,同时指向null又指向下一个节点? 不可能啊,这就不是一个单链表了
                    两个都有环
                        两个环形链表不相交
                        相交,相交节点在环外
                            可以统一理解为"入环节点"是同一个
                        相交,相交节点在环里
                            入环节点不是同一个
                        解决方案
                            1. 如果环形链表1和环形链表2的入环节点一样/同一个,那么很明显是上面第二种情况
                                然后求它的第一个相交节点,跟无环链表相交思路一样,只是把"入环节点"看作是尾节点嘛,然后拿到一个长的,一个短的,长的走"差值"步,然后两个依次遍历,直至相等为止,这个位置就是相交节点
                            2. 如果环形链表1和环形链表2的入环节点不一样,要么是情况1,要么是情况3
                                那如何区分呢? 
                                    就拿链表1举例,入环节点是loop1,链表2的入环节点是loop2,好,那就从loop1开始遍历,走一圈走回去
                                        如果没遇到loop2,那就是情况1,说明两个链表不相交,返回null
                                        如果中途遇到了loop2,那就是相交了,返回loop1/loop2都行
            4. 链表元素删除
                如果不给头节点,只给一个要进行删除的节点,如何删除
                    抖机灵,将这个要删除节点的下一个值赋给当前元素,然后通过当前元素把下一个值给删掉,变相地删除了当前元素

                    但是如果要删除的是最后一个元素(尾节点),那可能就做不到,因为没办法拿到删除元素的前一个元素,那也就不能将前一个元素的next置为null
    二叉树
        遍历 
            先序遍历,中序遍历,后序遍历
            其实一棵树总共有六种遍历方式,还有 头右左,右头左,右左头
        递归序
            每个节点都会跑三次,遍历到自己一次,左树跑完回来一次,右树跑完回来一次
        常用结论
            假定树中的一个值 X ,对树进行先序遍历和后续遍历先
                先序遍历: *****X*****
                后序遍历: *****X*****
                假定先序遍历中X的前半部分组成的元素集合为A,后序遍历中X的后半部分元素集合为B,那么A∩B=X的所有祖先节点

                证明
                    xxx,想一下就可以想出来
                    假定x在左边,那先序遍历在他前面的肯定都是祖先节点嘛,后序遍历在它后面的肯定都是右兄弟节点+祖先节点,那交集肯定就是祖先节点
                    假定x在右边,那么先序遍历在他前面的肯定都是祖先节点+左兄弟子树元素,后序遍历在它后面的肯定都是祖先节点,交集也是祖先节点
        迭代实现三种遍历---栈
            前序遍历
                思路
                    搞一个栈,然后呢,先将头节点存入栈中,然后弹出,弹出的时候打印,然后先将头节点的右节点存入栈中,再将左节点存进去,然后依次弹出,直至栈为空
                    栈嘛,先进后出嘛,那前序遍历,头左右嘛,头出来了之后,肯定先存右再存左,所以出来的时候那就是先左后右了
                代码实现
                    public static void preorderWalkWithIterator(Node head) {
                        if (head == null) {
                            return;
                        }
                        // 通过栈来实现
                        Stack<Node> stack = new Stack<>();
                        // 先将头节点加入到栈中
                        stack.push(head);

                        // 当栈不为空时,可以继续操作,直至栈为空,遍历完成
                        while (!stack.isEmpty()) {
                            Node node = stack.pop();
                            // 弹出来就打印
                            System.out.println(node.value);

                            // 查看弹出元素的左右子节点,将他们又存入栈中
                            Node rightChild = node.rightChild;
                            Node leftChild = node.leftChild;

                            // 因为是栈结构,而要实现先左后右,所以先存右子节点,再存左子节点
                            if (rightChild != null) {
                                stack.push(rightChild);
                            }
                            if (leftChild != null) {
                                stack.push(leftChild);
                            }
                        }
                    }
            后序遍历
                思路
                    使用两个栈,参考前序遍历的思路,前序遍历可以实现头左右,那么改一下可以将顺序变成头右左,那么把这个头右左倒序就是后续遍历,倒序怎么实现呢,再用一个栈嘛
                代码实现
                    public static void afterWalkWithIterator(Node head) {
                        if (head == null) {
                            return;
                        }
                        Stack<Node> nodeStack = new Stack<>();
                        Stack<Node> reverseStack = new Stack<>();

                        nodeStack.push(head);

                        while (!nodeStack.isEmpty()) {
                            Node node = nodeStack.pop();
                            // 此时弹出,那就不打印,直接存入另一个栈中
                            reverseStack.push(node);
                            Node leftChild = node.leftChild;
                            Node rightChild = node.rightChild;
                            if (leftChild != null) {
                                nodeStack.push(leftChild);
                            }
                            if (rightChild != null) {
                                nodeStack.push(rightChild);
                            }
                        }

                        // 此时就将二叉树中的所有元素按照 头右左的顺序压入到了reverseStack中,只需要将他们全部弹出,就是后续遍历
                        while (!reverseStack.isEmpty()) {
                            Node node = reverseStack.pop();
                            System.out.print(node.value + " ");
                        }
                    }
            中序遍历
                思路
                    总的来讲，中序遍历嘛，那肯定是先遍历左节点的，好，那第一步就把当前根节点所有的左子节点全部放入栈中，然后开始弹出
                    那第一次弹出的肯定是最左边的元素嘛，好，弹出之后，那就轮到他的右子节点了，看看有没有，有的话就压入栈中
                    右子节点又可能也有左子节点呀，那肯定还是要先扫一遍它的所有左子节点，然后存入栈中，然后又是依次弹出
                    整体思路就是这样，先搞左边，左边搞了之后，弹出来一个元素，看看右边还有没有，右边有的话，那又去看看它的左边有没有
                    而对于栈： 要弹出的元素就是要打印的
                    迭代不管前序遍历，中序遍历，后续遍历：都要用到栈这个结构，用来弹出遍历(暂存)
                代码实现
                    public static void middleWalkWithIterator(Node head) {
                        if (head == null) {
                            return;
                        }
                        // 先将头节点存入栈中
                        Stack<Node> stack = new Stack<>();
                        stack.add(head);
                        // 1. 先将头节点的所有左节点存入栈中,中序遍历嘛,左头右
                        Node leftChild = head.leftChild;
                        while (leftChild != null) {
                            stack.add(leftChild);
                            leftChild = leftChild.leftChild;
                        }
                        // 先将所有的存进去，存进去之后，那么准备开始弹出，这个时候第一次弹出的肯定是最左边的那个元素
                        while (!stack.isEmpty()) {
                            Node node = stack.pop();
                            // 弹出之后打印
                            System.out.println(node.value);
                            // 查看是否有右子节点，他可能有右孩子哦
                            Node rightChild = node.rightChild;
                            if (rightChild != null) {
                                // 如果真的有右孩子，那么就应该把右孩子也存入栈中，因为这个也要来打印的，他这个时候就相当于打印了头，然后肯定打印右嘛
                                node = rightChild;
                                stack.push(rightChild);
                                // 右孩子存进去之后，那不可能说存进去了，然后下次就直接打印了
                                // 右孩子还可能有左孩子，如果有左孩子，那肯定先打印左孩子，此时当前的右孩子就相当于头节点了嘛，那肯定要把这个右孩子的所有左孩子都存入栈中
                                // 将右子节点的所有子节点都存入到stack中，准备遍历
                                Node newLeftChild = node.leftChild;
                                while (newLeftChild != null) {
                                    stack.push(newLeftChild);
                                    newLeftChild = newLeftChild.leftChild;
                                }
                            }

                        }
                    }
        实现二叉树的按层遍历---队列
            思路
                使用队列实现,一开始,将根节点放队列中,然后弹出,弹出的时候打印,如果当前弹出的元素有左节点和右节点,就将他们依次放入队列中,然后再依次弹出,比如弹出根节点的左子节点,弹出来,然后看他有没有左右子节点啊,有的话那就将他们放入队列中,只是放进去啊,放进去之后接着弹出,弹出一个又去看它有没有左右子节点... 依次类推  直至队列为空

                总的来讲,就是挨个去看这些元素,将他们放入队列中,然后把他们弹出来的时候,去检查他们是否含有子元素,有的话依次放入队列,保证可以按层以及层的顺序存入队列
            代码实现    
                public static void walkByLevelWithQueue(Node head) {
                    if (head == null) {
                        return;
                    }
                    Queue<Node> queue = new LinkedList<>();
                    queue.add(head);

                    while (!queue.isEmpty()) {
                        Node node = queue.poll();
                        System.out.println(node.value);

                        Node leftChild = node.leftChild;
                        Node rightChild = node.rightChild;
                        if (leftChild != null) {
                            queue.add(leftChild);
                        }
                        if (rightChild != null) {
                            queue.add(rightChild);
                        }
                    }
                }
        二叉树的序列化+反序列化
            要将二叉树的结构通过另一种形式/结构(eg:字符串)保存到文件中,以便随时都能方便拿出来然后进行还原
            一个结构对应一颗二叉树,一一对应

            一般是 先序遍历/按层遍历 序列化
                有后序序列化,但是没有中序序列化,中序方式有歧义
                比如 
                      2         1 
                     /    和     \      采用中序方式序列化产生的结构都是一样的
                    1             2

            先序方式序列化
                序列化
                    可以搞一个结构用来存储序列化的结果嘛,字符串,数组,队列都行,然后先序地去将这些元素添加到这个结构中
                    null的值也要存起来,可以用来保证整体的结构+"确定哪个左子树结束"
                反序列化
                    思路
                        因为采用的是前序遍历的方式，那么根据序列化结果，肯定是获取当前的节点之后，依次获取到的是他的左子节点，直到为null说明当前左树走完
                        那么null之后的第一个元素很明显就是之前那个的右子节点，然后后面又是左子节点，又遇到null，此时这个二叉树左子树走完...
                    代码实现
                        private static Node preOrderDeserialize(Queue<Node> serialResult) {
                            // 当遇到第一个null的时候，说明左子树走完
                            if (serialResult == null) {
                                // 如果此时遇到了null，说明，当前对应的左子树已经走完了
                                // 就直接return一个空节点
                                return null;
                            }
                            Node head = serialResult.poll();
                            // 当前的节点获得之后，递归去获取左树的，直至左树遇到null
                            head.leftChild = preOrderDeserialize(serialResult);
                            head.rightChild = preOrderDeserialize(serialResult);
                            return head;
                        }
            按层方式序列化
                序列化
                    思路
                        搞一个结构用来保存序列化的结果,本质就是"按层遍历",只不过是遍历的时候加了一些其他的逻辑,比如要将每个元素加入到结构中
                    代码实现
                        public static Queue<String> serializeByLevelWalk(Node head) {
                            Queue<String> serialResult = new LinkedList<>();
                            if (head == null) {
                                serialResult.add(null);
                            }
                            Queue<Node> nodeQueue = new LinkedList<>();
                            nodeQueue.add(head);
                            while (!nodeQueue.isEmpty()) {
                                Node node = nodeQueue.poll();
                                serialResult.add(String.valueOf(node.value));
                                Node leftChild = node.leftChild;
                                Node rightChild = node.rightChild;
                                if (leftChild != null) {
                                    nodeQueue.add(leftChild);
                                    serialResult.add(String.valueOf(leftChild.value));
                                } else {
                                    serialResult.add(null);
                                }
                                if (rightChild != null) {
                                    nodeQueue.add(rightChild);
                                    serialResult.add(String.valueOf(rightChild.value));
                                } else {
                                    serialResult.add(null);
                                }
                            }
                            return serialResult;
                        }
                反序列化
                    思路
                        根据序列化结果，然后使用一个辅助的队列，这个队列主要用来存从序列化结果中弹出的值，然后原序列化结果中再弹出的值就是他的左右子节点，然后进行设置，设置完成之后将左右子节点也存入辅助队列中，直至序列化结果为空
                    代码实现
                        public static Node deserializeByLevelWalk(Queue<String> serialResult) {
                            if (serialResult == null || serialResult.size() == 0) {
                                // 说明为空嘛，直接返回null
                                return null;
                            }
                            // 需要一个辅助队列，来存储Node节点
                            Queue<Node> nodeQueue = new LinkedList<>();
                            // 先将第一个结果的值存入到辅助队列中,这个肯定是head节点
                            Node head = generateNode(serialResult.poll());
                            if (head != null) {
                                nodeQueue.add(head);
                            }
                            Node node = null;
                            while (!serialResult.isEmpty()) {
                                // 从辅助队列中弹出一个元素，然后从序列化结果中弹出两个元素设置为他的左节点+右节点
                                node = nodeQueue.poll();
                                // 先弹出来的肯定是左节点，后弹出来的是右节点
                                node.leftChild = generateNode(serialResult.poll());
                                node.rightChild = generateNode(serialResult.poll());

                                // 此时也应该把左子节点和右子节点加入到辅助队列中，因为序列化结果的队列中再弹出的时候，父节点就是上一次的左右节点
                                if (node.leftChild != null) {
                                    nodeQueue.add(node.leftChild);
                                }
                                if (node.rightChild != null) {
                                    nodeQueue.add(node.rightChild);
                                }
                            }
                            return head;
                        }
        求二叉树最宽的层有多少节点
            思路
                在搞一个 当前节点数  当前结束节点 下一层结束节点  最大节点数  

                就是说啥呢,在按层遍历的基础上,需要搞几个变量,要求最宽的层有多少节点嘛,那肯定要对比当前层和最大的层数量啊,那肯定也要有个标记来记录当前层哪个节点结束了嘛,遍历到每个节点的时候都要看当前层是否遍历结束了嘛,那这些操作也都只能是遍历上一层的时候进行记录,比如你肯定要先直到这一层哪个结束,但是呢,二叉树这种性质遍历当前层的时候根本做不到,所以只有在遍历上一层的时候,通过父元素的左右子节点来进行辨别,然后当在队列中弹出这个"结束节点"的时候,那么当前层的数量就可以计算了嘛(+1)是吧? 而且弹出的时候也要对下一层的结束节点判断

            详细思路
                整体上也是按层遍历，只不过是要注意在遍历的时候要把下一层的一些信息求出来
                主要就是记录当前层的节点数，下一层在哪个节点结束
                而当前层的节点数记录呢就需要用到当前层在哪里结束，结束的位置算出的当前层节点数就是最终当前层的节点数，拿着这个值和最大值相比
                而遍历当前层的时候，要一直更新和记录下一层的最终节点，等切换到下一层的时候，这个下一层的结束节点就变成了下一层的当前层结束节点
                总的来讲: 需要在遍历上一层的时候，记录下一层的节点信息，方便下面的操作，要不然是无法得知下一层在什么位置结束的
            代码实现
                public static int findWidestLevelCount(Node head) {
                    if (head == null) {
                        return 0;
                    }
                    int maxCount = 0;
                    int curCount = 0;
                    // 当前层的结束节点
                    Node curEndNode = head;
                    // 下一层的结束节点，默认设置为head的rightChild
                    Node nextEndNode = null;
                    // 按层遍历
                    Queue<Node> nodeQueue = new LinkedList<>();
                    nodeQueue.add(head);
                    // 常规按层遍历，里面会涉及到一些相关操作
                    while (!nodeQueue.isEmpty()) {
                        Node node = nodeQueue.poll();
                        // 只要不是最后的结束节点，那就说明还是在同一行
                        curCount++;
                        
                        Node leftChild = node.leftChild;
                        Node rightChild = node.rightChild;
                        if (leftChild != null) {
                            nodeQueue.add(leftChild);
                            // 更新下一层结束节点，如果有左子节点，那下一层的结束节点更新为当前节点的左子节点
                            nextEndNode = leftChild;
                        }
                        if (rightChild != null) {
                            nodeQueue.add(rightChild);
                            // 更新下一层结束的节点，如果有右子节点，那下一层的结束节点更新为当前节点的右子节点，总之要靠后
                            nextEndNode = rightChild;
                        }
                        if (node == curEndNode) {
                            // 说明当前节点就是结束节点
                            // 那么准备为下一行作准备
                            if (maxCount < curCount) {
                                maxCount = curCount;
                            }
                            // curCount清零
                            curCount = 0;
                            // 此时准备进入下一层，curEndNode更新为nextEndNode,因为后面是下一层在使用这个curEndNode
                            curEndNode = nextEndNode;
                        }
                    }
                    return maxCount;

                }
        给定一个带parent指针的二叉树,让求出它的后继节点(中序)
            后继节点: 比如采用前序遍历结果为 abcd  那么 b是a的后继节点,c是b的后继节点
            解决方案
                1. 传统方式啊,直接通过parent找到根节点,然后通过根节点进行对应的遍历获取到对应的后继节点,时间复杂度O(N)
                2. 既然都多给了一个parent,那么能不能找到一个O(K),K是当前节点到后继节点的距离的这样一个复杂度的算法
                    如果x有右子树,那很明显是右子树上的最左孩子
                    如果x没有右子树
                        如果是父节点的"右孩子",那么一直往上看,直到看到一个节点是它父节点的左节点为止,然后这个节点的父节点就是X的后继,如果没找到,那就没有后继,就是整棵树的最后一个节点
                        如果是父节点的"左孩子",那就是父节点
            代码实现
                public static NodeWithParent findSuccessorNodeOfMiddleOrderWalk(NodeWithParent nodeWithParent) {
                    // base case
                    if (nodeWithParent == null) {
                        return null;
                    }
                    NodeWithParent rightChild = nodeWithParent.rightChild;
                    // 判断node节点是否含有右子节点
                    if (rightChild != null) {
                        // 如果含有右子节点，那么后继节点必然是右子节点的最左的孩子
                        NodeWithParent newNode = rightChild;
                        while (newNode.leftChild != null) {
                            newNode = newNode.leftChild;
                        }
                        return newNode;
                    } else {
                        NodeWithParent tempNode = nodeWithParent;
                        while (tempNode.parent != null && tempNode == tempNode.parent.rightChild) {
                            tempNode = tempNode.parent;
                        }
                        return tempNode.parent;
                    }
                }
        微软面试题
            请把一段纸条竖着放在桌子上,然后从纸条的下边向上方对折1次,压出折痕后展开.此时折痕是凹下去的,即折痕突起的方向指向纸条的背面.如果从纸条的下边向上方连续对着2次,压出折痕后展开,此时有三条折痕,从上到下依次是下折痕,下折痕和上折痕
            给定一个输入参数N,代表纸条都从下边向上方连续对折N次,请从上到下打印所有折痕的方向.
                例如: N=1时,打印down,N=2时,打印 down down up
                二叉树的中序遍历
        二叉树基本算法+递归套路
            判断一颗二叉树是否为完全二叉树
                按层遍历
                    1. 如果没有左子节点而有右子节点,那肯定不是完全二叉树
                    2. 当第一次遇到左右子节点不双全的时候,剩下要遍历的节点必定要是叶子节点,如果在遍历违反了这个规则,那么必定不是完全二叉树
                代码实现
                    迭代实现
                        public static boolean isCBTWithIterator(Node head) {
                            if (head == null) {
                                return true;
                            }
                            // 按层遍历
                            boolean isEnd = false;
                            Queue<Node> nodeQueue = new LinkedList<>();
                            nodeQueue.add(head);

                            while (!nodeQueue.isEmpty()) {
                                // 弹出一个元素
                                Node node = nodeQueue.poll();
                                Node leftChild = node.leftChild;
                                Node rightChild = node.rightChild;
                                // 如果已经结束了，但是还是能找到孩子节点 + 如果一个节点只有左孩子，没有右孩子
                                if ((isEnd && (leftChild != null || rightChild != null)) || (leftChild == null && rightChild != null)) {
                                    return false;
                                }
                                if (leftChild == null || rightChild == null) {
                                    isEnd = true;
                                }
                                if (leftChild != null) {
                                    nodeQueue.add(leftChild);
                                }
                                if (rightChild != null) {
                                    nodeQueue.add(rightChild);
                                }
                            }
                            return true;
                        }
            二叉树递归套路
                判断二叉树是否是"平衡二叉树"
                    "平衡二叉树": 在这个二叉树中,"每一颗子树",左树的最大高度和右树的最大高度相差的绝对值不超过1,但凡有一颗子树不满足,那就不是平衡二叉树
                    问题拆分
                        要看头节点为head的二叉树是不是头节点,可以拆分为: 左数+右树都必须是平衡二叉树,并且左数和右树的高度差不超过1
                            光看左右树都是平衡二叉树也不足以确定当前的head节点的树就是平衡二叉树,因为如果即便两边都是平衡的,但是高度差超过了1,那整棵树也不是平衡的,所以大致来看,判断head节点的二叉树是否平衡,就要看左右两边是否都是平衡树+左右两边的高度,所以要拿到两个信息(1. 左右是否平衡  2. 左子树的高度+右子树的高度)
                    代码实现
                        public static boolean isBalancedBinaryTree(Node head) {
                            if (head == null) {
                                return true;
                            }
                            return process(head).isBalanced;
                        }
                        private static Info process(Node node) {
                            // 当是空节点的时候，默认为是平衡二叉树，并且高度为0
                            if (node == null) {
                                return new Info(true, 0);
                            }
                            // 收集信息
                            Info leftChildInfo = process(node.leftChild);
                            Info rightChildInfo = process(node.rightChild);

                            // 拿到左右子树的信息之后就可以生成当前的节点的信息并返回
                            // 要两个子树都平衡，并且高度差<=1，才平衡
                            boolean isBalanced = leftChildInfo.isBalanced && rightChildInfo.isBalanced && (Math.abs(leftChildInfo.height - rightChildInfo.height) <= 1);
                            int height = Math.max(leftChildInfo.height, rightChildInfo.height) + 1;
                            return new Info(isBalanced, height);
                        }
                判断二叉树是否是搜索二叉树
                    "搜索二叉树": 在一颗二叉树中,左子节点的值比父节点小,右子节点的值比父节点大
                        经典的搜索二叉树中没有重复值啊,也就是说不会出现相等的情况
                        那如果真的说是我有这个需求,要放两个权重/值一样的,比如我想放一个5(对应的值是A),还想放一个5(对应的值是B),那咋办
                            这个时候,欸我们还是拿着5去存,但是在节点内部呢,可以搞一个小s链表(链表存放值,A->B)这种,对于要进行排序的始终是唯一的
                    解决方案
                        1. 根据搜索二叉树的特性,可以用"中序遍历"嘛,中序遍历出来的结果如果都是递增的,那么就是一颗搜索二叉树,否则不是
                        2. 递归(问题划分)
                            左子树是不是搜索二叉树+右子树是不是搜索二叉树
                            "左子树的最大值"是不是小于当前节点+"右子树的最小值"是不是大于当前节点
                                注意: 如果只是单纯地判断左右子节点的值和当前值对比,是无法判断是否是搜索二叉树的,因为可能会出现右子树的最小值会比当前节点小,正常来讲,右子节点的所有值都应比当前值大(即便是最小值),所以只判断右子节点的值是无法判断的
                                左树也是一样的道理,不能单纯地只判断左子节点,要判断左子树的最大值(正常来讲左子树的所有值都应该比当前值小,搜索二叉树的特性)

                            分别提要求,让左数 右树都给出相关的信息,然后才能进行判断嘛
                            但是会发现,左树要的是(是否搜索树+最大值),右树要的是(是否搜索树+最小值),需要的两边信息不一样咋办? 递归又不会去定制,而是一视同仁,那咋整,这个时候搞信息的全集(是否搜索树+最大值+最小值)---全都要,那么就可以递归了

                            递归一律返回Info
                    代码实现
                        public static boolean isBST(Node head) {
                            if (head == null) {
                                return true;
                            }
                            return process(head).isBST;
                        }
                        private static Info process(Node node) {
                            if (node == null) {
                                return null;
                            }
                            // 获取两边的信息
                            Info leftChildInfo = process(node.leftChild);
                            Info rightChildInfo = process(node.rightChild);

                            int max = node.value;
                            // 求出当前树的最大值+最小值
                            if (leftChildInfo != null) {
                                max = Math.max(leftChildInfo.max, max);
                            }
                            if (rightChildInfo != null) {
                                max = Math.max(rightChildInfo.max, max);
                            }

                            int min = node.value;
                            if (leftChildInfo != null) {
                                min = Math.min(leftChildInfo.min, min);
                            }
                            if (rightChildInfo != null) {
                                min = Math.min(rightChildInfo.min, min);
                            }

                            boolean isBST = true;

                            if (leftChildInfo != null && !leftChildInfo.isBST) {
                                isBST = false;
                            }
                            if (rightChildInfo != null && !rightChildInfo.isBST) {
                                isBST = false;
                            }

                            if (leftChildInfo != null && leftChildInfo.max >= node.value) {
                                isBST = false;
                            }
                            if (rightChildInfo != null && rightChildInfo.min <= node.value) {
                                isBST = false;
                            }
                            return new Info(isBST, max, min);
                        }
                给定一颗二叉树的头节点head,任何两个节点之间都存在距离,返回整颗二叉树的最大距离
                    解决方案
                        二叉树递归,分情况嘛,因为要求最大距离
                            最大距离的路线,不经过Head节点,那么它要么是左边的最大距离,要么是右边的最大距离
                            最大距离的路线,经过Head节点,那么它必定是左边子树的最深长度+右边子树的最深节点长度(左边子树高度+右边子树的高度)

                            我也不确定最大路线是哪种,那么这三个中求出最大值,那肯定就是最大距离,毕竟最大嘛,要比较才知道谁是最大
                    代码实现
                        public static int findMaxDistance(Node head) {
                            if (head == null) {
                                return 0;
                            }
                            return process(head).maxDistance;
                        }
                        private static Info process(Node node) {
                            if (node == null) {
                                return new Info(0, 0);
                            }
                            Info leftChildInfo = process(node.leftChild);
                            Info rightChildInfo = process(node.rightChild);
                            // 当前节点所在树的高度
                            int height = Math.max(leftChildInfo.height, rightChildInfo.height);
                            // 如果最大距离经过当前节点，最大距离
                            int crossNodeMaxDistance = leftChildInfo.height + rightChildInfo.height + 1;
                            // Max(左右子树高度之和+1，左子树高度，右子树高度)
                            int maxDistance = Math.max(leftChildInfo.maxDistance, Math.max(rightChildInfo.maxDistance, crossNodeMaxDistance));
                            return new Info(maxDistance, height);

                        }
                判断一棵树是不是满二叉树
                    
                    思路1
                        "满二叉树":如果一棵树的高度是H,那么它的节点数是 2的H次方-1
                        收两信息: 高度 + 节点数  看看是否满足上述关系
                        代码实现
                            public class Info {
                                public int height;
                                public int nodeCount;

                                public Info(int height, int nodeCount) {
                                    this.height = height;
                                    this.nodeCount = nodeCount;
                                }
                            }
                            public static boolean isFullBinaryTree(Node head) {
                                    if (head == null) {
                                        return true;
                                    }
                                    Info info = process(head);
                                    return info.nodeCount == (1 << info.height) - 1;
                                }
                            private static Info process(Node node) {
                                if (node == null) {
                                    return new Info(0, 0);
                                }
                                Info leftChildInfo = process(node.leftChild);
                                Info rightChildInfo = process(node.rightChild);
                                int height = Math.max(leftChildInfo.height, rightChildInfo.height) + 1;
                                int nodeCount = leftChildInfo.nodeCount + rightChildInfo.nodeCount + 1;
                                return new Info(height, nodeCount);
                            }
                    思路2
                        看看两边是否都为满二叉树,如果有一个不是,那肯定就不是,如果都是,那看左右两边高度是否相等
                        收两信息: isFull + 高度  比对上面信息
                        代码实现
                            public class Info {
                                public boolean isFull;
                                public int height;

                                public Info(boolean isFull, int height) {
                                    this.isFull = isFull;
                                    this.height = height;
                                }
                            }
                            public static boolean isFullBinaryTree(Node head) {
                                if (head == null) {
                                    return true;
                                }
                                return process(head).isFull;
                            }
                            private static Info process(Node node) {
                                if (node == null) {
                                    return new Info(true, 0);
                                }
                                Info leftChildInfo = process(node.leftChild);
                                Info rightChildInfo = process(node.rightChild);
                                boolean isFull = leftChildInfo.isFull && rightChildInfo.isFull && (leftChildInfo.height == rightChildInfo.height);
                                int height = Math.max(leftChildInfo.height, rightChildInfo.height) + 1;
                                return new Info(isFull, height);
                            }
                        

                获取最大子搜索二叉树节点个数
                    思路
                        分情况嘛
                            如果最大子搜索二叉树以当前x节点作为头节点,就是说最大子搜索二叉树就是它本身
                                此时它的最大节点个数=Max(左树节点个数+右树节点个数)+1
                                又分情况
                                    左子树是不是搜索二叉树,右子树是不是搜索二叉树,如果有一个不是,那么就不是 
                                    如果都是,那么左子树的最大值是不是小于当前节点的值,右子树的最小值是不是小于当前节点的值
                                        另外,要得到节点个数,还要知道左子树和右子树的节点个数,然后+1
                                
                            如果最大子搜索二叉树不以当前x节点作为头节点,就是说它不是搜索二叉树,最大的搜索二叉树在它下边的左边/右边
                                那么此时最大搜索二叉树的节点个数就是Max(左边最大搜索子树节点,右边最大搜索子树节点)

                            所以,需要的信息就是(最大搜索子树节点,是不是搜索二叉树,最大值,最小值,当前树的节点个数)
                                当然了,如果最大搜索子树节点==当前树的节点个数,那么就可以直接判断当前树就是搜索二叉树,所以"是不是搜索二叉树"这个可以省略,不省略也行
                        具体情况
                            当x不做头时,即最大搜索二叉树不包括x
                                求的就是左子树最大搜索子二叉树和右子树最大搜索子二叉树的最大值
                            当x做头的时候,即最大搜索二叉树就是x树本身
                                如果左树和右树都是搜索树,同时也满足左树的最大值小于x值,右树的最小值大于x值,那么就可以进行计算
                                最大子搜索二叉树节点个数=左树节点+右树节点+1
                        最大搜索子树节点=三个值中的最大值
                            不经过x时
                                Max(左树的最大搜索二叉树节点,右树的最大搜索二叉树节点)
                            经过x时(左树是二叉搜索子树且max<x,右树是二叉搜索子树,且min>x)
                                左树节点+右树节点+1
                            判断嘛,具体经不经过x,靠(左树是二叉搜索子树且max<x,右树是二叉搜索子树,且min>x)判断
                    代码实现
                        public static int findMaxBSTNodeCount(Node head) {
                            if (head == null) {
                                return 0;
                            }
                            return process(head).maxBSTNodeCount;
                        }
                        private static Info process(Node node) {
                            if (node == null) {
                                return null;
                            }

                            Info leftChildInfo = process(node.leftChild);
                            Info rightChildInfo = process(node.rightChild);

                            int max = node.value;
                            int min = node.value;
                            int nodeCount = 1;
                            if (leftChildInfo != null) {
                                max = Math.max(max, leftChildInfo.max);
                                min = Math.min(min, leftChildInfo.min);
                                nodeCount += leftChildInfo.nodeCount;
                            }
                            if (rightChildInfo != null) {
                                max = Math.max(max, rightChildInfo.max);
                                min = Math.min(min, rightChildInfo.min);
                                nodeCount += rightChildInfo.nodeCount;
                            }

                            int maxBSTNodeCount = -1;
                            int crossNodeBSTCount = 0;
                            // 判断左树是否为搜索二叉树
                            boolean isLeftChildBST = leftChildInfo == null ? true : (leftChildInfo.maxBSTNodeCount == leftChildInfo.nodeCount);
                            // 判断右树是否为二叉搜索树
                            boolean isRightChildBST = rightChildInfo == null ? true : (rightChildInfo.maxBSTNodeCount == rightChildInfo.nodeCount);

                            // 判断是否都是二叉搜索树
                            if (isLeftChildBST && isRightChildBST) {
                                boolean leftChildMaxLessNode = leftChildInfo == null ? true : (leftChildInfo.max < node.value);
                                boolean rightChildMinMaxNode = rightChildInfo == null ? true : (rightChildInfo.min > node.value);
                                // 判断他们的最大值和最小值与node节点的关系
                                if (leftChildMaxLessNode && rightChildMinMaxNode) {
                                    int leftChildCount = leftChildInfo == null ? 0 : leftChildInfo.nodeCount;
                                    int rightChildCount = rightChildInfo == null ? 0 : rightChildInfo.nodeCount;
                                    maxBSTNodeCount = leftChildCount + rightChildCount + 1;
                                }
                            }

                            // 如果不过，那么求出Max(左树最大节点值，右树最大节点值，两个节点之和+1)
                            if (leftChildInfo != null) {
                                maxBSTNodeCount = Math.max(leftChildInfo.maxBSTNodeCount, maxBSTNodeCount);
                            }
                            if (rightChildInfo != null) {
                                maxBSTNodeCount = Math.max(rightChildInfo.maxBSTNodeCount, maxBSTNodeCount);
                            }

                            return new Info(maxBSTNodeCount, nodeCount, max, min);
                        }



                判断一棵树是不是完全二叉树(递归)
                    思路
                        判断是不是满的,是不是完全二叉树,还有高度也要拿出来
                        列可能性,可能性全列出来,通过向左右子节点要信息来根据可能性进行判断

                        左树满,右树满,左树高度-右树高度<=1
                        左树满,右树完全,左树高度=右树高度,要不然不是
                        左树完全,右树满,左树高度=右树高度+1

                        结果初始值都是当节点为null的时候设置的,然后递归结果逐层返回
                    代码实现
                        public class Info {
                            public boolean isFull;
                            public boolean isCBT;
                            public int height;

                            public Info(boolean isFull, boolean isCBT, int height) {
                                this.isFull = isFull;
                                this.isCBT = isCBT;
                                this.height = height;
                            }
                        }
                        public static boolean isCBTWithRecursion(Node head) {
                                if (head == null) {
                                    return true;
                                }
                                return process(head).isCBT;
                            }

                            private static Info process(Node node) {
                                if (node == null) {
                                    return new Info(true, true, 0);
                                }

                                Info leftChildInfo = process(node.leftChild);
                                Info rightChildInfo = process(node.rightChild);

                                boolean isFull = false;
                                boolean isCBT = false;
                                int height = Math.max(leftChildInfo.height, rightChildInfo.height) + 1;
                                // 两边都是full的情况下
                                if (leftChildInfo.isFull && rightChildInfo.isFull) {
                                    if (leftChildInfo.height == rightChildInfo.height) {
                                        isFull = true;
                                        isCBT = true;
                                    } else if (leftChildInfo.height == rightChildInfo.height + 1) {
                                        isCBT = true;
                                    }
                                } else if (leftChildInfo.isFull && rightChildInfo.isCBT) {
                                    if (leftChildInfo.height == rightChildInfo.height) {
                                        isCBT = true;
                                    }
                                } else if (leftChildInfo.isCBT && rightChildInfo.isFull) {
                                    if (leftChildInfo.height == rightChildInfo.height + 1) {
                                        isCBT = true;
                                    }
                                }
                                return new Info(isFull, isCBT, height);
                            }
                获取最大子搜索二叉树的头节点---TODO
                给定一个二叉树的头节点head和另外两个节点a和b,返回这两个节点的最低公共祖先
                    解决方案
                        1. 传统方式
                            搞一个HashSet,然后遍历二叉树,当遍历到a的时候,将他所有父节点都存起来,然后遍历到b,依次去找他的父节点,如果能在hashset中找到的第一个节点,那就找到了

                            虽然时间复杂度还行,但是空间复杂度上去了
                        2. 递归 
                            要得到最低公共祖先嘛,最低公共祖先说明什么
                                1. 如果这个最低公共祖先就是x节点的话,那么必然
                                    a/b其中一个节点在左边,一个节点在右边
                                    或者x节点是a/b其中一个,而另一个不在左边就在右边
                                2. 如果这个最低公共祖先不是x节点的话,那么必然
                                    a/b都在x的左边或者在x的右边
                                    要么x下面不同时存在a/b

                                递归的过程中,如果是找到了最低公共祖先节点(比如就在左边/在右边),那么再往上,就直接返回这个节点,也不用做操作了,反正要一层一层递归到最上边,找到了就不要动他嘛
                                如果左树没答案,右树也没答案,那么这个时候就要分情况判断,可能一个在左边一个在右边,也可能两边都没有
                                    如果a找到了,b也找到了,那么答案就是他自己x
                                    诶,那你说不对啊,那如果a,b都在左边呢? 如果a,b都在左边,上边判断答案找没找到从下往上递归就已经包含了,所以不会出现这种情况
                多叉树---Happy值
                    表示 
                        public static class Node{
                            public int value;
                            public List<Node> nexts;
                        } 
                    Happy值
                        有一棵经典的多叉树,表示一个公司的管理体系,现在呢,每个节点表示一个员工,每个员工有一个happy值,表示该员工的快乐程度,现在,有一个聚会,要邀请公司员工,规定: 如果邀请一个员工,那么他的直属上下级就不能被邀请过来,好,问: 这样邀请之后,来的员工,他们的happy值加起来最大的是哪一种情况? 

                        解决方案
                            X来的时候,获得的最大happy值是多少?
                            X不来的时候,获得的最大happy值是多少?
                            两者的最大值
                            最终答案到底是跟X有关还是无关,相当于把不确定怎么走的情况,给他定死在了几种情况之中,这个就是列可能性,虽然说越往细里想想不通,但是可以问题拆分,那就拆分成自己嘛,小问题,递归嘛

                        可能性划分
                            比如: X下面直属有a,b,c
                            1. X来 
                                X来的话,那么最大的happy值的情况就是: X的happy值+abc不来的最大happy值
                            2. X不来 
                                X不来的话,那么最大的happy值情况就是: 0+Max(a来,a不来)+Max(b来,b不来)+Max(c来,c不来)
                                    X不来,那么就一定是abc来的最大happy值吗? 不一定吧,abc也可以不来嘛,只要最大就好,不一定说X不来,abc就一定来
                                    那这样又相当于是拆分了

                            就是,分节点来不来,如果父节点来,那么子节点就不来,那么对于X节点,分两种情况,来/不来,来的时候他的最大happy值是什么,不来的时候他的最大happy值是什么
                        
                    代码实现
                        public static int getMostHappyValue(Node employee) {
                            if (employee == null) {
                                return 0;
                            }
                            Info info = process(employee);
                            return Math.max(info.comingHappyValue, info.notComingHappyValue);
                        }

                        private static Info process(Node employee) {
                            if (employee == null) {
                                return new Info(0, 0);
                            }

                            int notComingHappyValue = 0;
                            int comingHappyValue = 0;
                            for (Node next : employee.nexts) {
                                Info nextInfo = process(next);
                                // 当前节点来，下属节点就不能来，所以他的最大happy值就是下属不来的最大happy值
                                comingHappyValue += nextInfo.notComingHappyValue;
                                // 当前节点不来，那可能下属节点来，也可以不来，所以他的最大happy值就是下属来和不来中较大的那个happy值
                                notComingHappyValue = Math.max(nextInfo.comingHappyValue, nextInfo.notComingHappyValue);
                            }
                            return new Info(notComingHappyValue, comingHappyValue);
                        }
                主要是先分: 结果跟当前节点有没有关系? 会不会涉及当前节点

                对null情况做处理(base case),然后收信息,拿到信息之后进行处理判断,也返回一个信息
                    信息里面,有几个信息是比较好获取的,然后有的信息需要通过其他信息进行判断才能获取

                总结
                    时间复杂度
                        都是O(N) 树形DP
                        因为一个节点都只会经过3次,所以相当于是做了一个遍历,O(N),N是树的节点个数,"最优解"
                    通过头节点,向左右子树要信息,要到信息之后就可以进行处理,列可能性
                        常见分类: 目标跟Head有关的时候,目标跟Head无关的时候
                        模板化:  Info, Info process(), 方法调用
                    作用+好处
                        可以解决面试中绝大多数的二叉树问题尤其是树形DP问题
                        本质是利用递归遍历二叉树的便利性
                    递归套路
                        1. 假设以X节点为头,假设可以向X左子树和右子树要到任何信息
                        2. 在上一步的假设下,讨论以X为头节点的树,得到答案的可能性☆☆☆
                        3. 列出所有可能性后,确定到底需要向左数和右树要什么样的信息
                        4. 把左树信息和右树信息"求全集",就是任何一颗子树都需要返回的信息Info
                        5. 递归函数都返回Info,每一颗子树都这么要求
                        6. 写代码,在代码中考虑如何把左数的信息和右树的信息整合出整棵树的信息
                主要是练习如何列举可能性
    贪心算法
        概述
            总是得出某一局部最好的解法,然后把这些最好的解法都列出来,看看能不能得到一个全局最优解
            如果用局部的一个想法贪出了最优解,那么就说明这个贪心策略有效,如果没有搞出最优解,那么对应的贪心策略无效
        概念
            1. 最自然智慧的算法
            2. 用一种"局部""最功利"的标准,总是做出"在当前看来是最好的选择"
            3. 难点在于证明最功利的标准可以得到全局最优解
            4. 对于贪心算法的学习主要以增加阅历和经验为主

            贪心算法可能贪的对,也可能贪不对

            就是每次我都按照最好的来,如果能整出最优解,那就说明当前这个方法是对的嘛,如果整不出来,那就G,但凡举一个反例出来,那当前这个策略必定无效
        给定一个字符串数组strs,必须把所有的字符串拼接起来,返回所有可能的拼接结果中,字典序最小的
            字典序: 排字符串大小的方式,两个字符串都要放进字典的时候,要先放哪一个(abcd会放在b的前面,a比b小嘛,虽然b的长度小一些)
                两个字符串长度一样的时候
                    一位一位排,直接比对应的ascii码大小,比如abc,bca,字典序:abc<bca
                两个字符串不一样的时候
                    将短的补字符,补成长度和长字符串一样长,用最小的ascii码/比最小的ascii码去补,然后一位一位比对大小
                    eg: abcd 和 b 
                        b会进行补位,补三位,变成b***,然后呢再和abcd一位一位比对大小,第一位a<b,所以abcd<b 
        贪心算法笔试出现的较多,但是面试出现的较少,主要是看标准/贪心策略对不对 要么用个排序,要么用个堆(还不用自己手写堆)
            贪心策略在面试场上区分度不够,想出来了就是100,想不出来就是0
        解题套路
            贪心策略就"不证明",要证明也是通过对数器使用暴力方法证明,只管去试
            会议安排
                一个项目要占用一个会议室宣讲,会议室不能同时容纳两个项目的宣讲,给你每一个项目开始的时间和结束的时间,你来安排宣讲的日程,要求会议室进行的宣讲场次最多,返回最多的宣讲场次

                按照最早开始的===不行 
                按照会议持续时间最短的===不行
                按照会议结束时间最早的===可以
                代码实现
                public class Program {
                    public int start;
                    public int end;
                    public Program(int start, int end) {
                        this.start = start;
                        this.end = end;
                    }
                }
                public class ProgramComparator implements Comparator<Program> {
                    @Override
                    public int compare(Program o1, Program o2) {
                        // 按照会议的结束时间生序排序
                        return o1.end - o2.end;
                    }
                }
                public static int bestArrangement(Program[] programs) {
                        // 先将所有的会议按照最早结束时间排序
                        Arrays.sort(programs, new ProgramComparator());
                        int timeLine = 0;
                        int result = 0;
                        for (int i = 0; i < programs.length; i++) {
                            if (timeLine <= programs[i].start) {
                                result++;
                                timeLine = programs[i].end;
                            }
                        }
                        return result;
                }
            黄金分割铜板问题
                哈夫曼编码---经典贪心算法
                    没有为什么,如果想知道为什么,要去看哈夫曼编码怎么证明的,就是靠经验
                题意
                    给定一个整数数组,然后得到他们的总和,比如现在有一块金条,长度就是总和的长度,现在要对金条进行分割,保证分隔之后的长度和原数组一样(顺序不管),分割的时候需要花费和金条长度等量的铜板,比如金条长度是20,要分隔成10和10,就需要花费20个铜板,问:怎样分隔才能使得花费的铜板数最小?

                    使用小根堆
                        先将所有元素都放入到小根堆中,然后弹出两元素,将他们相加得到一个和,再将这个和放入到小根堆中,再弹出两个数,依次类推,直到小根堆中只剩下一个元素,在这个过程中构建一棵树,这棵树从上往下的顺序就是分割的顺序,哈夫曼编码,不要去证明
                代码实现
                    public static int splitGoldWithLeastCopper(int[] arr) {
                        // 小根堆
                        PriorityQueue<Integer> heap = new PriorityQueue<>();
                        int totalSum = 0;
                        int singleSum = 0;
                        for (int num : arr) {
                            heap.add(num);
                        }
                        while (heap.size() > 1) {
                            // 弹出两个最小的,求出他们的和,然后再放进去，周而复始，直至堆为空
                            Integer least = heap.poll();
                            Integer secLeast = heap.poll();
                            singleSum = least + secLeast;
                            totalSum += singleSum;
                            heap.add(singleSum);
                        }
                        return totalSum;
                    }
            投资利润问题
                题意
                    输入:正数数组costs,正数数组profits,正数K,正数M
                    costs[i]表示i号项目的花费/成本,profits[i]表示i号项目在扣除花费之后还能挣到的利润,K表示只能串行地最多做K个项目,M表示你拥有的初始资金
                    说明: 每做完一个项目,马上获得收益,可以支持你去做下一个项目.不能并行地做项目
                    输出要求: 你最后获得的最大钱数
                思路
                    那就是在自己的资金范围内,投资收益最大的项目呗,然后资金不就变多了吗?然后再拿着这笔资金,又去投资收获最大的项目,依次类推,直至K次/没有可以投资的了(兜里的钱满足不了剩下的项目投资了)
                实现 
                    用两个堆,一个小根堆,一个大根堆,小根堆以cost进行排序,大根堆以profit进行排序,然后呢,这个资金M,每次去小根堆cost里面看,能够解锁哪些项目peek一下,好,如果能解锁,就把这些项目全放到大根堆中去,然后呢,就去大根堆中每次把收益最大的那个项目拿出来,依次类推循环K次
                    第二次,项目做了之后K更新了嘛,更新了之后,又去小根堆看,诶?可以解锁哪些项目,然后又放入到大根堆中,注意,这里只是解锁小根堆,具体能收益多少还是要看大根堆里面最顶上那个元素
                    注意 
                        也不是每一次都会解锁新的项目,资金不够了那肯定解锁不了的,如果在K次范围之内,大根堆为空了,那么就说明没有要解锁的了,就返回当前的资金嘛
                代码实现
                    public class Project {
                        public int cost;
                        public int profits;
                        public Project(int cost, int profits) {
                            this.cost = cost;
                            this.profits = profits;
                        }
                    }
                    public class MinCostComparator implements Comparator<Project> {
                        @Override
                        public int compare(Project o1, Project o2) {
                            return o1.cost - o2.cost;
                        }
                    }
                    public class MaxProfitsComparator implements Comparator<Project> {
                        @Override
                        public int compare(Project o1, Project o2) {
                            return o2.profits - o1.profits;
                        }
                    }
                    public static int getMaxCapital(int[] costs, int[] profits, int K, int capital) {
                        // 构建按照成本升序的小根堆
                        PriorityQueue<Project> costHeap = new PriorityQueue<>(new MinCostComparator());
                        // 构建按照收益降序的大根堆
                        PriorityQueue<Project> profitHeap = new PriorityQueue<>(new MaxProfitsComparator());

                        // 刚开始将所有的项目都先加入小根堆中
                        for (int i = 0; i < costs.length; i++) {
                            costHeap.add(new Project(costs[i], profits[i]));
                        }
                        // 投资K次
                        for (int i = 0; i < K; i++) {
                            // 先看一下小根堆中哪些项目可以解锁，依次放入profits的大根堆中
                            while (!costHeap.isEmpty() && capital >= costHeap.peek().cost) {
                                // 弹一个项目出来放进大根堆
                                profitHeap.add(costHeap.poll());
                            }
                            // 此时，当前资金capital能够解锁的项目都放在大根堆了，且大根堆中是按照利润最大排序的，弹出即可
                            // 如果此时大根堆不为null才进行弹出，为空就不要弹了，直接退出方法，说明此时没有可以要解锁的了
                            if (profitHeap.size() != 0) {
                                capital += profitHeap.poll().profits;
                            } else {
                                break;
                            }
                        }
                        return capital;
                    }


            路灯问题
                如果连着的三个位置都是点,那就是贪心
                题意
                    给定一个字符串str,只由'X'和'.'两种字符构成
                    'X'表示墙,不能放灯,也不需要点亮
                    '.'表示居民点,可以放灯,需要点亮
                    如果灯放在i位置,可以让i-1,i和i+1三个位置被点亮
                    返回如果点亮str中所有需要点亮的位置,需要几盏灯
                思路
                    就是分情况讨论呗,如果这个点是X怎么怎么样,如果是.怎么怎么样,如果是.,那他后一位是啥,怎么判断怎么设置,要不要放灯,后一位是X怎么办,后一位是.又怎么办,后一位是.去判断后后一位,然后判断之后,将当前指针怎么移动,又依次往复判断

                    就是列可能性,根据可能性进行判断,那同时...在中间位置放个灯,那实际上也是贪心算法嘛

                    只往后看,不看前面
                代码实现
                    public static int minLight(String road) {
                        if (road == null || road.length() == 0) {
                            return 0;
                        }
                        int lightCount = 0;
                        int index = 0;
                        while (index < road.length()) {
                            if (road.charAt(index) == 'X') {
                                index++;
                            } else {
                                lightCount++;
                                // 再看下一个位置是否也是.
                                if (index + 1 == road.length()) {
                                    break;
                                } else {
                                    if (road.charAt(index + 1) == 'X') {
                                        index = index + 2;
                                    } else {
                                        // 此时不论index+2是X还是.,都要进行在index+1的位置放一个灯,可以保证灯的数量最小
                                        index = index + 3;
                                    }
                                }
                            }
                        }
                        return lightCount;
                    }
            贪心要么靠经验(做题),要么靠自然智慧
    并查集
        解决什么样的问题?
            并查集一般解决的是对于给定的多个集合之间的"合并","分组","查询是否在同一个集合"等动态连接性问题
        特点
            性能好
            如果一共有n个样本,调用isSameSet(a,e)和union(a,e)很频繁,能够做到均摊下来单次的时间复杂度为O(1)

            用其他结构也可以实现并查集,但是时间复杂度很高
                比如用list,a在listA中,b在listB中,c在listC中,那么这个时候肯定要搞一张表去维护哪个元素在哪个链表中,比如整个Hash表,如果说要union(a,c),就是把c移到listA中去,然后listC就不要了,此时也要去维护HashSet将c的关系移动到listA,这样单个还好,那如果listA中100w条数据,listC中也100w条数据,要进行union,要将listC中所有的元素的关系都移动到listA,那时间复杂度就很高了
        并查集怎么实现的呢?
            比如说a,b,c,d刚开始分别对应{a}{b}{c}{d}四个集合,那么每个集合中的元素都有一条指向自己的指针
            isSameSet(a,c)
                此时a往上指,指到头也是自己,c往上指,指到头也是自己,这个指到头的节点叫做"代表节点",诶发现a和c的代表节点不一样,所以他两不在同一个集合中
            union(a,c)
                先看他们的代表指针嘛,不是同一个(a是a,c是c,他们自己),然后获取他们每个集合的大小,都是1,直接让c的指针指向a,那么这样a的代表指针也是a,c的代表指针也是a,那就属于是同一个集合

                那此时,如果说再让c所在集合和e所在的集合进行合并呢? union(c,e)
                    先求出c对应的代表节点是a,e的代表节点是e,a的集合大小是2,e的大小是1,让小的去挂大的,就是将e的代表节点(他自己)指向c的代表节点

                那么以后再去查询a,c,e是否属于同一个集合,都会变成true,因为他们的代表节点都是同一个
            这样就使得isSameSet()和union()的时间复杂度都是O(1),就是改一下指针,集合就合并了,判断是否是同一个集合,也只是判断一下代表节点这个属性,是拿代表节点确定是哪个集合的

            并查集初始化的时候,会为每一个样本建立一个小集合,比如a,b,c,d四个样本,就会建立对应{a}{b}{c}{d}四个集合
        实现 
            节点对应表(值对应节点)
            节点对应的父亲节点存储表(节点,父节点)
            集合大小存储表(代表节点,大小size)
                只是存储代表节点的大小,对于那些不是代表节点的节点,不存储他们,是通过代表节点来标识是哪一个集合的
            只有代表节点的parent指向自己,用map取代了指针
        优化
            1. 集合数量小的代表节点去挂/指向集合数量大的代表节点
            2. 使用map取代了链表指针

            3. 寻找代表节点的时候,扁平化处理,比如a->b->c->d->e a的代表节点是e,那么那要一个一个从Hash表中找到,好,但凡经过一个,就把节点存入一个栈中,直至找到,找到之后,将栈中的元素依次弹出,设置他们的代表节点为e,那么后续如果再有这些节点相关的寻找代表节点的需求,就可以很快找到,毕竟查一次HashMap就能找出来

                这个变更的就是父元素,说实话父元素变更对后边也没啥影响,集合嘛,知道这玩意儿在集合里面就行

            代表节点
        代码实现
            public class Node<V> {
                V value;

                public Node(V v) {
                    this.value = v;
                }
            }
            public class UnionFindSet<V> {
                // 使用一系列集合，替代链表操作，保证均摊下来isSameSet()和union()的时间复杂度为O(1)===>只涉及到链表指针的移动
                // 用于保存所有节点的map，同时也维护value和节点的关系
                public HashMap<V, Node<V>> nodes;

                // 用来存储每一个节点的父亲节点，取代了链表结构
                // 每一个节点都只有一个父亲节点，所以这里面维护了所有节点和其父节点的关系
                public HashMap<Node<V>, Node<V>> parents;

                // 维护了每个集合的大小是多少，但是不是每一个节点都有记录，只记录代表节点和所在集合的大小
                public HashMap<Node<V>, Integer> sizeMap;

                /**
                * 初始化，给每个元素都建小集合
                *
                * @param values 样本
                */
                public UnionFindSet(List<V> values) {
                    nodes = new HashMap<>();
                    parents = new HashMap<>();
                    sizeMap = new HashMap<>();
                    for (V value : values) {
                        Node node = new Node(value);
                        nodes.put(value, node);
                        parents.put(node, node);
                        sizeMap.put(node, 1);
                    }
                }

                /**
                * 找到目标节点的代表节点/最顶上那个节点
                *
                * @param node 目标节点
                * @return 代表节点
                */
                private Node findRepresentativeNode(Node node) {
                    if (node == null) {
                        return null;
                    }
                    Stack<Node<V>> nodeStack = new Stack<>();
                    // 判断是否到达了代表节点，如果到达了，那么他的父节点就是他自己
                    while (node != parents.get(node)) {
                        // 此时这里就要把经过的每一个节点都加入到栈中去，进行优化，方便后期这些节点再去查找代表节点的时候，他的父亲节点就是代表节点，更改父亲节点不影响
                        nodeStack.push(node);
                        // 上移
                        node = parents.get(node);
                    }
                    // Stack栈中的数据弹出来，将他们的父节点设置为对应的代表节点
                    while (!nodeStack.isEmpty()) {
                        parents.put(nodeStack.pop(), node);
                    }
                    return node;
                }


                /**
                * 判断两个元素是否在同一个集合中
                * 就是判断两个元素对应节点的代表节点是否是同一个，如果在同一个集合中，那代表节点肯定是同一个，否则不然
                *
                * @param a a
                * @param b b
                * @return true/false
                */
                public boolean isSameSet(V a, V b) {
                    return findRepresentativeNode(nodes.get(a)) == findRepresentativeNode(nodes.get(b));
                }

                /**
                * 将两个集合合并起来
                * 思路
                * 先找到他两各自的代表节点，判断是否是同一个，同一个就不用合并
                * 然后拿到他两集合的大小，小的挂到大的上面去(相当于是一个小小的优化，相比于大的挂小的，降低后期时间复杂度)
                * 因为是通过集合替换链表的，所以对于parents和sizeMap两张表进行更新
                *
                * @param a a
                * @param b b
                */
                public void union(V a, V b) {
                    // 先找到两个的祖先节点
                    Node representativeNodeA = findRepresentativeNode(nodes.get(a));
                    Node representativeNodeB = findRepresentativeNode(nodes.get(b));

                    if (representativeNodeA != representativeNodeB) {
                        // 这个时候就要获取两个的长度，将小的挂到大的上去
                        Integer sizeA = sizeMap.get(representativeNodeA);
                        Integer sizeB = sizeMap.get(representativeNodeB);

                        Node larger = sizeA > sizeB ? representativeNodeA : representativeNodeB;
                        Node smaller = sizeA < sizeB ? representativeNodeA : representativeNodeB;

                        // 小的挂到大的上去，并且同时更新各个表
                        parents.put(smaller, larger);
                        sizeMap.put(larger, sizeA + sizeB);
                        // 从sizeMap中删除掉较小节点的元素个数，因为已经
                        sizeMap.remove(smaller);
                    }
                }
            }
        唯一痛的地方就是
            链的长度太长,这个会影响时间复杂度(找代表节点的时候痛),其他的操作都是O(1)的
                比如查看是否是相同的集合啊,那就是找到他们的代表节点,可能会走链表的长度次,但是这里有优化
                    一个是让小的去挂大,比如两个集合,A集合100个和B集合5个元素,如果让100去挂5,那A中100个元素可能都要变长,那如果小的挂大的,只有5个元素变长了嘛
                    HashMap取代练表
                    节点元素对应的代表节点扁平化处理,痛就只痛第一次,第一次这些元素要去走链表的长度步,以后直接走一步


                    所有的优化都是按照 链变短去优化的
                两个集合union啊,那就是变动一下指针就行,O(1)
        结论
            如果样本量为N,那么如果findHead()---找代表节点,很频繁,到达或超过O(N)的规模,那么以后再findHead()的时候,查询时间复杂度O(1)

            当然了,必定有一个时刻,链条会很长,他会走很慢,但是基本仅限于第一次,第一次之后,对应链上所有的元素(从那个节点开始找所经过的每一个节点)的父节点就是代表节点了嘛,查找时间复杂度就是O(1),所以均摊下来的话,时间复杂度就是O(1)

            不要去证明啊,人家证明了20多年才证出来
        题目
            朋友圈LeetCode 547 
                求朋友圈有多少个,给定一个正方形的二维数组,行和列都相等,求有多少个朋友圈,并查集嘛,朋友圈最大的个数不会超过行/列,所以初始并查集的大小就是二维数组的维度
            岛问题
                题意
                    给定一个二维数组matrix,里面的值不是1就是0,只要上下左右相邻的1认为是一片岛,返回matrix中岛的数量
                解决方案
                    1. 感染===递归
                        感染之后就要把感染过的值给变了,时间复杂度O(M*N)
                    2. 并查集方式
                        将二维数组中每一个元素都看作一个样本,刚开始肯定每个都是一个小集合,然后去看他左边和上边的元素,如果是1,就进行合并union
                        并查集是通过Dot(空类)的二维数组实现的,用于区分不同的1
                        通过Hash表作为并查集,常数项比较大,但是时间复杂度较低
                    3. 也是并查集
                        但是实现并查集是通过一维数组实现的
                    合并之后集合大小要--

            并查集是指并和查的结构
    图
        概述
            图是由点的集合和边的集合构成的
            分为有向图+无向图,但所有的图都可以看作/转为是有向图,无向图就双向指针互相指嘛
            边上可能带有权值

            链表和树可以看作是比较特殊的图
        图的表示
            邻接表法
                记录每一个节点他的邻居是谁
                    比如a下一条路可能走向b,c,d 那么就表示为 a: b,c,d 如果带了权重,那么也可以在bcd元素存储的时候带上权重
                可以认为就是一个Hash表,数组+List,数组中存那些点,数组元素对应的链表存他的邻接元素 比如数组某个下标位置存a,然后a指向b,c,d这样 
            邻接矩阵法
                搞一个二维数组
                    比如这个图总共有abc三个节点,那么搞一个3*3的二维数组,横着是abc,竖着也表示abc,a到a肯定就没有路径嘛,就存个0,a到b有路径,有路径就存他的权重值,如果a到c没有路径可以访问,那就存一个无穷大或者其他可以标识的值
                    总之就是一个二维数组,里面存了对应的权重啊这些
            面试最常见的表示法
                给一个大数组,里面有很多长度为3的小数组,比如[[4,3,2],[5,2,7],[2,1,3]...]这样来表示图
                那这个究竟是表示的啥意思呢?
                    小数组第一个值是权重,第二个值是起始位置,第三个值是到达位置
                    第一个小数组拿出来,[4,2,3]代表2--->3的权重是4,[5,2,7]代表2--->7的权重是5,[2,1,3]代表1--->3的权重是2...

                    几个小数组/这个二维数组有多少行就代表多少条边
            也可以用一个一维数组来表示图
                数组的下标位置表示从哪个节点开始,数组的值表示到达哪个节点
                比如[3,1,1,1]
                    0--->3,1--->1,2--->1,3-->1
                    但是这个就没有距离/权重,不是说非得表示距离/权重
        经典的图结构
            Node
                值  value
                入度 int in(有多少个点直接指向它的)
                出度 int out(它直接指向多少个点)
                邻居 List<Node> nexts;  "从它出发"的能找到的直接邻居集合
                边  List<Edge> edges;   "从它出发"的边的集合
            Edge
                权重/距离 weight 
                起点 Node from 从哪个Node点开始
                终点 Node to   到达哪个Node点
            Graph 图
                点集 HashMap<Integer,Node> nodes;   用来表示对应的Node关系 (0===>0号节点)
                边集 HashSet<Edge> edges;
            代码表示
                public class Node{
                    public int value;
                    public int in;
                    public int out;
                    public List<Node> nexts;
                    public List<Edge> edges;
                }
                public class Edge{
                    public int weight;
                    public Node from;
                    public Node to;
                }
                public class Graph{
                    public HashMap<Integer,Node> nodes;
                    public HashSet<Edge> edges;
                }
        将面试常见的二维数组转换成上述结构
            主要是将面试出现的二维数组转换成我们平常熟悉的的结构,转换接口
            代码实现
                public static Graph convertToGraph(int[][] matrix) {
                    Graph graph = new Graph();
                    for (int i = 0; i < matrix.length; i++) {
                        int weight = matrix[i][0];
                        int fromValue = matrix[i][1];
                        int toValue = matrix[i][2];

                        // 看看图中的点集合中是否已经包含from和to,有的话就从集合中获取,没有就构建节点
                        Node fromNode = graph.nodes.get(fromValue);
                        if (fromNode == null) {
                            fromNode = new Node(fromValue);
                            // 加入到集合中
                            graph.nodes.put(fromValue, fromNode);
                        }
                        Node toNode = graph.nodes.get(toValue);
                        if (toNode == null) {
                            toNode = new Node(toValue);
                            graph.nodes.put(toValue, toNode);
                        }
                        Edge edge = new Edge(weight, fromNode, toNode);
                        graph.edges.add(edge);

                        fromNode.nextNodes.add(toNode);
                        fromNode.edges.add(edge);
                        fromNode.outDegreeNum++;

                        toNode.inDegreeNum++;
                    }
                    return graph;
                }
        遍历
            宽度优先遍历(BFS)---Breath First Search
                思路
                    其实跟二叉树的"按层遍历"思路是一致的,也是搞一个队列,然后从出发节点依次压入"队列"中,但是还要额外搞一个Set,因为图它是可能跑回去的,二叉树就不存在,一走走到底,不会往回跑,所以需要用一个Set来记录之前已经跑过的元素
                代码实现
                    public static void bfsWalk(Node startNode) {
                        if (startNode == null) {
                            return;
                        }
                        Queue<Node> nodeQueue = new LinkedList<>();
                        HashSet<Node> nodeSet = new HashSet<>();

                        // 先将开始节点加入到两个结构中
                        nodeQueue.add(startNode);
                        nodeSet.add(startNode);

                        // 开始从栈中弹出
                        while (!nodeQueue.isEmpty()) {
                            // 弹出即打印
                            Node node = nodeQueue.poll();
                            System.out.println(node);
                            // 通过node获取他所有的邻居
                            for (Node nextNode : node.nextNodes) {
                                // 如果这个节点之前没有遇到过，那么就压入栈中，并且同时加入到HashSet中标识已经出现过
                                if (!nodeSet.contains(nextNode)) {
                                    nodeQueue.add(nextNode);
                                    nodeSet.add(nextNode);
                                }
                            }
                        }
                    }
            深度优先遍历(DFS)
                思路 
                    一条路走到死, 一条路走完之后,往回退,看看退回去上一个节点有没有其他的路可以走,之前走过的路就不会走了啊,没走过的路,就走然后打印,直到走完

                    需要一个Set,打印过的节点存入到Set中嘛,可以实现不走环路+避免重复打印
                    使用栈,栈存放目前走的整条路径

                    先将开始元素存入栈中，同时也存入set中，然后依次弹出栈中的元素
                    弹出来的元素，这个时候要去检查他的那些邻居节点，依次遍历看看set中他们有没有被遇到过
                    如果set中有，说明被遇到过，那么就跳过(说明当前这条路已经走完了嘛)
                    如果没有，那说明当前这条路还没走过，于是准备走这条路，但是也要把当前这个节点加入到栈中
                    (因为后面这条路走完，还需要通过这个节点去看他的下一个邻居节点有没有走过，因此需要也添加到栈中),并且把他的这个邻居节点也加入到栈中,跳出循环(一次只走一条路嘛,监测到当前这条路有节点没遇到过,就一直沿着这条路走)...
                    直至栈为空,实现完成过
                代码实现
                    public static void dfsWalk(Node startNode) {
                        if (startNode == null) {
                            return;
                        }
                        Stack<Node> nodeStack = new Stack<>();
                        HashSet<Node> nodeSet = new HashSet<>();

                        nodeStack.add(startNode);
                        System.out.println(startNode.value);
                        nodeSet.add(startNode);

                        while (!nodeStack.isEmpty()) {
                            Node node = nodeStack.pop();
                            for (Node nextNode : node.nextNodes) {
                                if (!nodeSet.contains(nextNode)) {
                                    // 此时就还需要将当前弹出来的节点存入栈中，因为他可能有很多个邻居节点，以后还需要用到其他的邻居节点(已经走过的邻居节点就会存入到HashSet中,下次不会再走)
                                    nodeStack.push(node);
                                    nodeStack.push(nextNode);
                                    System.out.println(nextNode.value);
                                    // 此时就进行跳出，因为只走这一条路，走到头
                                    break;
                                }
                            }
                        }
                    }
        拓扑排序
            概念
                按照顺序把工作做完,不缺依赖的顺序就是拓扑序

                就是说啥呢,跟那个编译包的顺序是一样的,a依赖于b,b依赖于c,那么编译的时候,肯定要先编译c嘛,再编译b,再编译a,这个顺序就是cba,就是拓扑排序(反序)

                所以为什么不能循环依赖,因为对于拓扑序来讲,他一定要是有向图,并且无环,一旦有环了,那先编译谁??? 它就不知道怎么个顺序,所以必须要是"有向无环图"

                图的拓扑排序就是从最开始排

            拓扑排序不唯一
                比如abc都依赖了d,那么编译出来的顺序 abcd,bacd,cabd...都对

            无环的图是不是多叉树?
                不是,他可能右父亲节点指向左父亲节点的子节点去了,这样根本就不是树了嘛
            解法
                根据入度解决
                    先找到入度为0的节点,把他们拧出来,然后呢把他们的影响去掉,比如a的入度为0,但是a指向了bc,那么就把a指向bc的指针断掉,bc的入度也就变成0了,然后再把入度为0的元素拧出来,反复操作直至为空
                    出来的顺序就是拓扑序

                    如果采用上述的图结构,是可以直接拿到所有的节点的,只不过不是按照宽度优先啊/深度优先的顺序来的
                点次解法
                    点次: 统计当前节点之后,往后走一遍,经过的节点数,可重复,就是一个节点可能一条路也经过了,另一条路也经过了,那也算,把他们的和加起来
                    X和Y两个节点,如果从X往后走一遍,包括X,经过的点次是A,Y往后走一遍,包括Y,经过的点次是B,如果A>B,那么在拓扑序中,X就会排在Y的前面
                    eg
                        如果x全走一遍,得到的节点数是100,y全走一遍,得到的节点数是80,那么在拓扑序中,x在y的前面
                            这是个啥意思,就是说如果在一个图中,从x开始往后走,走过的节点数次数是比从y走走过的节点数次数多的,那么最后拓扑序排出来,拓扑序中,x肯定在y的前面或者跟y相等,拓扑序x<=y 
                            x不一定包括y
                            那x在y的前边,那肯定就是先出来嘛,那拓扑序就是x<=y嘛
                最大深度解法
                    X和Y两个节点,如果X走过的最大深度>=Y走过的最大深度,那么拓扑序,X<=Y
                    就是X在Y的前面嘛
            动态规划本心
                就是走过一遍之后为了后期不重复走,把之前的记下来
        最小生成树---Kruskal算法
            给一个无向图(必须是无向图⭐️),在不影响所有边都连通的情况下,所有边的权重加起来的最小值是多少? 
                就是说在这个无向图中,我可以去掉一些边,但是要保证所有的点都能够连接起来,那每个边不都有权重值吗? 有取舍, 我要求能够连接起来的情况下,权重值最小的那一种方案
            解决方案
                贪心算法+并查集
            思路
                先搞一个并查集嘛,然后这个图中所有的节点都是样本,搞一些小集合出来(并查集),然后呢,将图中的所有的边啊,按照权重大小存起来(边节点中包含权重,从哪个节点,到哪个节点),搞一个比较器,存入"堆"中
                然后利用贪心算法,每次拿权重最小的边出来,看看两个节点如果连起来会不会成为一个环(isSameSet()),如果能,那就将小集合union起来,如果不能(就是判断isSameSet()判断两个节点在同一个集合,那就是成环了),那就不要连,跳过它,直至堆为空
                最终就找到了这个最小生成树
            代码实现
                public static Set<Edge> kruskalMST(Graph graph) {
                    UnionFindSet unionFindSet = new UnionFindSet();
                    unionFindSet.generateUnionFindSet(graph.nodes.values());

                    // 形成小根堆,将所有的边，按照权重大小存入其中
                    PriorityQueue<Edge> edgeHeap = new PriorityQueue<>(new EdgeComparator());
                    Set<Edge> edges = new HashSet<>();
                    for (Edge edge : graph.edges) {
                        edgeHeap.add(edge);
                    }
                    while (!edgeHeap.isEmpty()) {
                        // 弹出当前最小的边
                        Edge edge = edgeHeap.poll();
                        // 判断他两个节点是否在同一个并查集
                        if (!unionFindSet.isSameSet(edge.from, edge.to)) {
                            // 如果不在，则合并
                            unionFindSet.union(edge.from, edge.to);
                            edges.add(edge);
                        }
                    }
                    return edges;
                }
        最小生成树---Prim算法
            思路
                一个已经解锁过的节点的集合,一个探索过的已知的可以考虑的边的集合,一个结果集合

                出发点进来,进来就解锁了嘛,加入到解锁节点集合中,好去看他的所有边,那么看完就代表所有边已经探索过,加入到对应边集合(小根堆)中,然后呢,在所有已经探索过的边中,找到一个权重最小的,然后找到这个边之后,就把另一头的节点给解锁了嘛,加入到解锁过的节点中,这个时候要判断之前有没有解锁过哦,没解锁过就解锁,然后这条边就要了,解锁了之后然后呢又把它的边给解锁了,新增的一些边加入到可以考虑的解锁过的边集合中,然后又从考虑的边集合中选出一个最小的又去解锁节点... 

                解锁过的节点用一个HashSet来存,因为要判断是否出现过嘛
                解锁过的边用小根堆存起来,因为每次都要拿一个最小的出来嘛
                结果集合也用HashSet存,唯一的嘛


            大致思路
                通过点去找边,然后再通过边去找点,点找边,边找点...
                通过点去探索边嘛,探索之后从中选出一个最小的之前没有被采用过的点,然后再通过新点去找新的一些边

                不走回头路,对于之前已经解锁过的节点,如果选中的边又跑回去了,看看之前已经解锁过的点集合中有没有,有的话那就不要,重新选一条边出来
            代码实现
                public static Set<Edge> primMST(Graph graph) {

                    // 搞一个小根堆用来存放解锁过的边，那么以后每通过一个点解锁了新的边，就可以存放到这个小根堆中,弹出也是从这个小根堆中每次弹出最小的
                    PriorityQueue<Edge> edgeHeap = new PriorityQueue<>(new EdgeComparator());

                    // 用来保存已经解锁过的点
                    Set<Node> nodeSet = new HashSet<>();

                    // 用来存放结果的边的Set集合，同时也可以用来判断当前的边是否已经解锁过
                    Set<Edge> resultEdgeSet = new HashSet<>();

                    // 直接随便挑一个点
                    for (Node node : graph.nodes.values()) {
                        // 因为直接遍历所有嘛，而不是直接拿一个点出来，所以加一层判断可以避免所有的节点都走一遍
                        // 先将node中的所有边全部存入小根堆中
                        nodeSet.add(node);
                        for (Edge edge : node.edges) {
                            edgeHeap.add(edge);
                        }
                        while (!edgeHeap.isEmpty()) {
                            Edge curMinEdge = edgeHeap.poll();
                            Node toNode = curMinEdge.to;

                            // 看看是否已经存在过这个to节点
                            if (!nodeSet.contains(toNode)) {
                                // 如果不存在，那么当前弹出来的最小边可以放入到结果集中
                                resultEdgeSet.add(curMinEdge);
                                nodeSet.add(toNode);
                                // 并且去看这个node对应的边
                                for (Edge edge : toNode.edges) {
                                    edgeHeap.add(edge);
                                }
                            }
                        }
                        // 走到这里说明其实已经完整走过一遍了，已经通过这个点将最小生成树结果搞出来放到set中去了，所以直接break，保证了看似是个循环，实际是只用了一个出发点
                        break;
                    }
                    return resultEdgeSet;

                }
        迪杰斯特拉算法
            要求
                "有向无负权重的图"
                整个环权重累加和为负数的图存在,一直转转转,那就无穷小溢出了嘛,负数

            给定一个点,要求出这个点到每一个节点的最短路径
                结果就是一张表,这张表一律对这个节点负责,求出它到每一个节点的最短路径
                如果到不了,那就设置无穷
                怎么生成这张表
            思路 
                假如从a节点开始
                先把这张表搞出来,存储了目标节点到每一个节点的最短路径,
                初始化的时候到自己肯定是0,其他节点肯定都是正无穷/或者不进行初始化嘛,然后呢从里面弹出一个权重最小的开始(第一次肯定是自己 0),去看他的边以及权重,好收集一波,诶发现到下一层的几个点的权重比表中的小,那么就替换表中的值
                第一波a走完,然后锁住
                然后把他的边全部扫完之后,又去表中挑一个最小的出来,那这个时候挑出来的值,就是初始节点(a)到当前节点的最小值,拿出来之后又去找他的边,计算对应各自的权重,如果比表中的小,就进行替换
                这是第二波,把对应的拿出来的节点锁住不动
                ... 周而复始

                当然了,每次从表中拿出没有被锁住的数据可以用加强堆优化一下
            代码实现
                private static Node getMinUnlockedNode(HashMap<Node, Integer> resultMap, HashSet<Node> lockedNodeSet) {
                    Node minUnlockedNode = null;
                    int minDistance = Integer.MAX_VALUE;
                    for (Map.Entry<Node, Integer> entry : resultMap.entrySet()) {
                        Node node = entry.getKey();
                        Integer distance = entry.getValue();
                        if (!lockedNodeSet.contains(node) && distance < minDistance) {
                            minUnlockedNode = node;
                            minDistance = distance;
                        }
                    }
                    return minUnlockedNode;
                }
                public static HashMap<Node, Integer> normalDijkstra(Node startNode) {
                    if (startNode == null) {
                        return null;
                    }
                    // 结果集
                    HashMap<Node, Integer> resultMap = new HashMap<>();
                    // 锁定的节点集合
                    HashSet<Node> lockedNodeSet = new HashSet<>();
                    // 先将开始节点加入到result中
                    resultMap.put(startNode, 0);
                    // 从结果集中拿出那个当前距离最小且没有被锁定的节点
                    Node minUnlockedNode = getMinUnlockedNode(resultMap, lockedNodeSet);
                    while (minUnlockedNode != null) {
                        Integer toMinNodeDistance = resultMap.get(minUnlockedNode);
                        // minUnlockedNode 为null的时候，代表此时所有的节点都已经锁定，也就是所有的节点都扫过了，可以结束了
                        // 获取minUnlockedNode的边,遍历他们,和resultMap中的表进行对比,然后根据这条边找到对应的节点,去更新resultMap
                        for (Edge edge : minUnlockedNode.edges) {
                            Node toNode = edge.to;
                            Integer distance = edge.weight;
                            if (!resultMap.containsKey(toNode) || distance < resultMap.get(toNode)) {
                                resultMap.put(toNode, distance + toMinNodeDistance);
                            }
                        }
                        // 这个节点的所有的边走扫了一遍之后，好，当前节点就会被锁定，下次不会再拿出来
                        lockedNodeSet.add(minUnlockedNode);
                        minUnlockedNode = getMinUnlockedNode(resultMap, lockedNodeSet);
                    }
                    return resultMap;
                }
            优化
                使用加强堆对 那一步 进行处理优化
                从表中拿数据出来的时候,需要找到元素在哪,然后呢也会涉及到对他的值进行变更,那么变更之后我下一次还是需要拿最小的出来,用堆就很合适,然后需要先找到元素在哪嘛,改了之后还需要让他自己维护结构,那么就用加强堆
                改完值之后涉及到调整堆,所以用加强堆  系统提供的堆实现不了

                思路 
                    搞一个小根堆,先将所有元素对应的最小距离存进去,刚开始肯定只有一个(a,0),然后弹出最小的来,就是(a,0),去找a节点的邻居节点,算出到他们的最小距离,然后都放入堆中,依次类推,算完之后就把(a,0)加入到另一个集合中(相当于是锁住了,因为堆里面没有了弹出来了嘛,下一次肯定不会再弹出这个元素了),后面再从堆中弹出最小的,周而复始,但是可能说,后面的过程中算出来的结果比堆中已经存在的小,那这个时候就是要使用"加强堆"的特性,先找到他,然后对值进行更改,调整堆的结构... 
                代码实现
                    GreaterHeap
                        ...
                    public static HashMap<Node, Integer> dijkstraOptimize(Node startNode, int size) {
                        if (startNode == null) {
                            return null;
                        }
                        // 获取一个size大小的堆对象
                        GreaterHeap greaterHeap = new GreaterHeap(size);
                        // 结果集
                        HashMap<Node, Integer> resultMap = new HashMap<>();

                        // 将startNode加入到堆中
                        greaterHeap.addOrUpdate(startNode, 0);

                        // 从堆中弹出元素
                        while (!greaterHeap.isHeapEmpty()) {
                            NodeDistance nodeDistance = greaterHeap.pop();
                            Node node = nodeDistance.node;
                            int distance = nodeDistance.distance;
                            // 获取node节点所有的边
                            for (Edge edge : node.edges) {
                                greaterHeap.addOrUpdate(node, distance + edge.weight);
                            }
                            // 把当前弹出来的元素和距离直接存入结果集中，因为弹出来的就是最小的嘛
                            resultMap.put(node, distance);
                        }
                        return resultMap;
                    }
    暴力递归
        汉诺塔问题
            不能违反小压大原则
            解决方案
                1. 把小过程全搞出来
                    比如我要从最左边移动到最右边,那么就可以拆分为,(n-1)的先全部移动到中间,然后n移动到右边,然后(n-1)全部移动到右边,那么左--->中又可以拆分,中--->右也可以拆分... 都要进行拆分
                    终止条件就是如果n==1,直接移动/打印
                2. 抽象出来 from,to,other 递归
                    六合一
                递归函数可以通过增加参数的方式增加可能性
                    六个函数被搞成一个了嘛
            时间复杂度/移动步数
                2的n次方-1
                要想把所有的移动步骤打出来,一定至少是这个 最优解的步数,为啥说最优解呢,最小的那个玩意儿一会刚移过去又移过来没意义啊
        递归一定要有黑盒思维,当一个递归函数含义固定了,就把它当作黑盒来用
        题目
            求字符串的子序列问题
                代码实现
                    public static List<String> printAllSubSequences(String s) {
                        if (s == null || s.length() == 0) {
                            return new ArrayList<>();
                        }
                        char[] chars = s.toCharArray();
                        List<String> result = new ArrayList<>();
                        String path = "";
                        process(chars, 0, result, path);
                        return result;
                    }

                    private static void process(char[] chars, int index, List<String> result, String path) {
                        if (index == chars.length) {
                            // 将path加入到结果集中
                            result.add(path);
                            return;
                        }
                        // 当前位置可要可不要
                        // 要
                        process(chars, index + 1, result, path + chars[index]);
                        // 不要
                        process(chars, index + 1, result, path);
                    }
            求字符串的子序列问题,要求不出现重复字面值的子序列
                代码实现
                    public static List<String> printAllSubSequencesNoRepeat(String s) {
                        if (s == null || s.length() == 0) {
                            return new ArrayList<>();
                        }
                        char[] chars = s.toCharArray();
                        List<String> result = new ArrayList<>();
                        String path = "";
                        HashSet<String> set = new HashSet<>();
                        process(chars, 0, set, path);
                        for (String str : set) {
                            result.add(str);
                        }
                        return result;
                    }

                    private static void process(char[] chars, int index, HashSet<String> set, String path) {
                        if (index == chars.length) {
                            set.add(path);
                            return;
                        }
                        // 要当前字符
                        process(chars, index + 1, set, path + chars[index]);
                        // 不要当前字符
                        process(chars, index + 1, set, path);
                    }
            打印一个字符串的全部排列
                代码实现
                    public static List<String> permutations(String str) {
                        if (str == null || str.length() == 0) {
                            return new ArrayList<>();
                        }
                        List<String> result = new ArrayList<>();
                        char[] strs = str.toCharArray();
                        process(strs, 0, result);
                        return result;
                    }

                    private static void process(char[] strs, int index, List<String> result) {
                        if (index == strs.length) {
                            result.add(new String(strs));
                        } else {
                            for (int i = index; i < strs.length; i++) {
                                swap(strs, index, i);
                                process(strs, index + 1, result);
                                swap(strs, index, i);
                            }
                        }
                    }

                    private static void swap(char[] strs, int index1, int index2) {
                        char temp = strs[index1];
                        strs[index1] = strs[index2];
                        strs[index2] = temp;
                    }
            打印一个字符串的全部排列,要求不出现重复
                代码实现
                    方式一(set)
                        public static List<String> permutationsNoRepeat(String str) {
                            if (str == null || str.length() == 0) {
                                return new ArrayList<>();
                            }
                            char[] strs = str.toCharArray();
                            List<String> result = new ArrayList<>();
                            HashSet<String> set = new HashSet<>();
                            process(strs, 0, set);
                            for (String s : set) {
                                result.add(s);
                            }
                            return result;
                        }

                        private static void swap(char[] strs, int index1, int index2) {
                            char temp = strs[index1];
                            strs[index1] = strs[index2];
                            strs[index2] = temp;
                        }

                        private static void process(char[] strs, int index, HashSet<String> set) {
                            if (index == strs.length) {
                                set.add(new String(strs));
                            } else {
                                for (int i = index; i < strs.length; i++) {
                                    swap(strs, index, i);
                                    process(strs, index + 1, set);
                                    swap(strs, index, i);
                                }
                            }
                        }
                    方式二(boolean 数组)
                        public static List<String> permutationsNoRepeat2(String str) {
                            if (str == null || str.length() == 0) {
                                return new ArrayList<>();
                            }
                            char[] strs = str.toCharArray();
                            List<String> result = new ArrayList<>();
                            process2(strs, 0, result);
                            return result;
                        }

                        private static void process2(char[] strs, int index, List<String> result) {
                            if (index == strs.length) {
                                result.add(String.valueOf(strs));
                            } else {
                                boolean[] isVisited = new boolean[256];
                                for (int i = index; i < strs.length; i++) {
                                    if (!isVisited[strs[i]]) {
                                        isVisited[strs[i]] = true;
                                        swap(strs, index, i);
                                        process2(strs, index + 1, result);
                                        swap(strs, index, i);
                                    }

                                }
                            }
                        }


            移除栈底元素
            逆序一个栈但是不用额外的数据结构
                代码实现
                    public static void reverse(Stack<Integer> stack) {
                        if (stack.isEmpty()) {
                            return;
                        }
                        int i = removeStackFloor(stack);
                        reverse(stack);
                        stack.push(i);
                    }

                    public static int removeStackFloor(Stack<Integer> stack) {
                        int result = stack.pop();
                        if (stack.isEmpty()) {
                            return result;
                        } else {
                            int last = removeStackFloor(stack);
                            stack.push(result);
                            return last;
                        }
                    }



            清除现场
    动态规划
        概述
            就是走过一遍之后为了后期不重复走,把之前的记下来
            如果发现有重复调用的过程,动态规划在算过一次之后将答案记录下来,下次再遇到重复过程,直接调用获取答案,某种程度上来讲是空间换时间

            就比如说 斐波拉切数列
                如果使用传统递归的方式,那会导致重复计算的问题,比如f(6)=f(5)+f(4),f(5)=f(4)+f(3)... 这样实际上就是重复计算了,对于已经算过的值并没有保存起来

                递归优化(缓存)时间复杂度是O(n),跟从头开始算(迭代)时间复杂度是一样的(从头开始算,也是用一个sum将值保存起来嘛)
        暴力递归+优化?
        题目
            机器人走路
                题意
                    假设有排成一行的N个位置,记为1~N,N一定大于或等于2
                    开始时机器人在其中的M位置上(M一定是1~N中的一个)
                    如果机器人来到1位置,那么下一步只能往右来到2位置
                    如果机器人来到N位置,那么下一步只能往左来到(N-1位置)
                    如果机器人来到中间位置,那么下一步可以往左走也可以往右走
                    规定机器人必须走K步,最终来到P位置(P也是1~N中的一个)的方法有多少种?
                    给定四个参数N,M,K,P,返回可行的方法数量
                暴力递归解法
                    就相当于是每个位置都给他尝试一遍
                优化
                    1. 计算过的值不再重复计算
                        空间换时间=记忆化搜索=从顶向下的动态规划

                        中途位置是可以进行优化的,比如走到了(7,10),目标位置在7,还剩下10步,这个时候再往下走可以走到(6,9)+(8,9),而(6,9)又可以走到(5,8)+(7,8),(8,9)也可以走到(7,8)+(9,8),那么就出现了两个(7,8),而出现这两个(7,8)对结果是不影响的,所以可以进行优化

                        用缓存进行优化,保证之前算过的不再重复计算,而是直接拿缓存表
                        二维动态规划表
                        状态转移只是结果,不是原因,非常强调尝试(自然智慧)
                从顶向下的动态规划,也叫做 记忆化搜索
                代码实现
                    暴力递归
                        public static int robotWalking(int range, int location, int leftStep, int targetLocation) {
                            if (range < 2 || location < 1 || location > range || leftStep < 1 || targetLocation < 1 || targetLocation > range) {
                                return -1;
                            }
                            return process(range, location, leftStep, targetLocation);
                        }
                        public static int process(int range, int location, int leftStep, int targetLocation) {
                            // base case 什么时候说明已经到达目标位置了/达成目标了, 当机器人就在目标位置上，且此时步数也已经用尽
                            if (leftStep == 0) {
                                // 此时说明当前方法可行，数量直接返回为1
                                return location == targetLocation ? 1 : 0;
                            }
                            // 那接下来都是没有到达目标的情况
                            // 当机器人在1位置的时候，此时机器人只能向右走
                            if (location == 1) {
                                // location后移，步数-1
                                return process(range, location + 1, leftStep - 1, targetLocation);
                            }
                            // 机器人在N位置的时候，此时只能向左走
                            if (location == range) {
                                return process(range, location - 1, leftStep - 1, targetLocation);
                            }
                            // 当机器人向左走的情况
                            int goLeft = process(range, location - 1, leftStep - 1, targetLocation);
                            // 机器人向右走的情况
                            int goRight = process(range, location + 1, leftStep - 1, targetLocation);
                            // 总的方法数=左走方法数+右走方法数
                            return goLeft + goRight;
                        }
                    暴力递归优化(加入缓存)
                        public static int robotWalkingWithCache(int range, int location, int leftStep, int targetLocation) {
                            if (range < 2 || location < 1 || location > range || leftStep < 1 || targetLocation < 1 || targetLocation > range) {
                                return -1;
                            }
                            // 通过可变参数 location+leftStep进行优化
                            // location的取值范围是: 1~range,leftStep的取值范围就是: 1~leftStep，因此设置二维数组的初始容量为[range+1][leftStep+1]
                            int[][] dp = new int[range + 1][leftStep + 1];
                            // 对dp缓存进行初始化

                            for (int i = 0; i < dp.length; i++) {
                                for (int j = 0; j < dp[i].length; j++) {
                                    dp[i][j] = -1;
                                }
                            }
                            return optimizedProcess(range, location, leftStep, targetLocation, dp);
                        }
                        public static int optimizedProcess(int range, int location, int leftStep, int targetLocation, int[][] dp) {

                            // 先从缓存中获取
                            if (dp[location][leftStep] != -1) {
                                return dp[location][leftStep];
                            }
                            if (leftStep == 0) {
                                return location == targetLocation ? 1 : 0;
                            }
                            int result = 0;
                            if (location == 0) {
                                result = optimizedProcess(range, location + 1, leftStep - 1, targetLocation, dp);
                            } else if (location == range) {
                                result = optimizedProcess(range, location - 1, leftStep - 1, targetLocation, dp);
                            } else {
                                result = optimizedProcess(range, location - 1, leftStep - 1, targetLocation, dp)
                                        +
                                        optimizedProcess(range, location + 1, leftStep - 1, targetLocation, dp);
                            }
                            dp[location][leftStep] = result;
                            return result;
                        }
                    动态规划
                        public static int robotWalkingWithDP(int range, int location, int leftStep, int targetLocation) {
                            if (range < 2 || location < 1 || location > range || leftStep < 1 || targetLocation < 1 || targetLocation > range) {
                                return -1;
                            }

                            int[][] dp = new int[range + 1][leftStep + 1];

                            dp[4][0] = 1;
                            // 按照列填完整个表
                            for (int col = 1; col < dp[0].length; col++) {
                                for (int row = 1; row < dp.length; row++) {
                                    if (row == 1) {
                                        dp[row][col] = dp[row + 1][col - 1];
                                    } else if (row == dp.length - 1) {
                                        dp[row][col] = dp[row - 1][col - 1];
                                    } else {
                                        dp[row][col] = dp[row - 1][col - 1] + dp[row + 1][col - 1];
                                    }
                                }
                            }
                            return dp[location][leftStep];
                        }
            纸牌===TODO 没理解
                题意
                    给定一个整形数组arr,代表数值不同的纸牌排成一条线
                    玩家A和玩家B一次拿走每张纸牌
                    规定玩家A先拿,玩家B后拿
                    但是每个玩家每次只能拿走最左或最右的纸牌
                    玩家A和玩家B都绝顶聪明
                    请返回最后获胜者的分数
                一个先手,一个后手,两个方法互相调用
                暴力递归 
                缓存优化
                严格表依赖 
                    就是看怎么二维数组中的元素如何依赖的
                    先看basecase
            背包问题
                题意
                    给两个等长的数组W和V,W数组为重量数组,V数组为价值数组,i下标就可以表示重量和价值,两数组中的数值都是大于等于0的,bag表示背包有多大,可以自由挑选货物放进背包里,但是重量累加不能超过bag,求能够返回的最大价值
                从左往右的尝试 暴力递归
                    判断啊,判断当前背包是否还能装下这个东西
                代码实现
                    暴力递归 
                            public static int getKnapsackMaxValueWithViolenceRecursion(int[] weights, int[] values, int bagSize) {
                                if (weights == null || weights.length == 0 || values == null || values.length == 0 || bagSize < 0) {
                                    return -1;
                                }
                                return processWithViolenceRecursion(weights, values, bagSize, 0);
                            }
                            public static int processWithViolenceRecursion(int[] weights, int[] values, int bagSize, int index) {
                            if (index == weights.length) {
                                return 0;
                            }
                            // 第一个要还是不要
                            // 当前下标的value不要时,走到下一个下标
                            int noNeed = processWithViolenceRecursion(weights, values, bagSize, index + 1);

                            // 当前下标value要的时候，先判断当前bagSize是否装的下当前的weight,装不下就是0
                            int need = bagSize > weights[index] ? values[index] + processWithViolenceRecursion(weights, values,
                                    (bagSize - weights[index]), index + 1) : 0;

                            return Math.max(need, noNeed);
                            }
                    暴力递归优化
                            public static int getKnapsackMaxValueWithCache(int[] weights, int[] values, int bagSize) {
                                if (weights == null || weights.length == 0 || values == null || values.length == 0 || bagSize < 0) {
                                    return -1;
                                }
                                int[][] cache = new int[weights.length + 1][bagSize + 1];
                                for (int i = 0; i < cache.length; i++) {
                                    for (int j = 0; j < cache[i].length; j++) {
                                        cache[i][j] = -1;
                                    }
                                }
                                return processWithCache(weights, values, bagSize, 0, cache);
                            }
                                public static int processWithCache(int[] weights, int[] values, int bagSize, int index, int[][] cache) {
                                if (cache[index][bagSize] != -1) {
                                    return cache[index][bagSize];
                                }
                                if (index == weights.length) {
                                    return 0;
                                }
                                int result = 0;
                                // 不要当前位置的value
                                int noNeed = processWithCache(weights, values, bagSize, index + 1, cache);
                                int need = bagSize > weights[index] ? values[index] + processWithCache(weights, values,
                                        bagSize - weights[index], index + 1, cache) : 0;

                                result = Math.max(noNeed, need);
                                return result;
                    dp
                        public static int dp(int[] weights, int[] values, int bagSize, int index) {
                            if (weights == null || weights.length == 0 || values == null || values.length == 0 || bagSize < 0) {
                                return -1;
                            }
                            int[][] dp = new int[weights.length + 1][bagSize + 1];
                            for (int row = weights.length; row > 0; row--) {
                                for (int col = 0; col < bagSize; col++) {
                                    if (row != weights.length) {
                                        int v1 = dp[row + 1][col];
                                        int v2 = col > weights[row] ? values[row] + dp[row + 1][col - weights[row]] : -1;
                                        dp[row][col] = Math.max(v1, v2);
                                    }
                                }
                            }
                            return dp[0][bagSize];
                        }
            字符串转换
                题目
                    规定1和A对应,2和B对应,3和C对应... 26 和Z对应
                    那么一个数字字符串比如"111"就可以转换为:"AAA","KA","AK"
                    给定一个只有数字字符组成的字符串str,返回有多少种转化结果
                代码实现
                    暴力递归 
                        private static int process(char[] chars, int index) {
                            if (index == chars.length) {
                                // 数组都走完了，那返回1，说明当前路径有效
                                return 1;
                            }
                            if (chars[index] == '0') {
                                return 0;
                            }
                            // 当前总是可以取一个的
                            int ways = process(chars, index + 1);
                            // 判断是否能取下一个
                            // 当下一个已经到了末尾，那肯定就取不了了
                            if (index + 1 == chars.length) {
                                return ways;
                            }
                            int num = (chars[index] - '0') * 10 + (chars[index + 1] - '0');
                            if (num <= 26) {
                                ways += process(chars, index + 2);
                            }
                            return ways;
                        }
                    暴力递归优化
                        private static int processWithCache(char[] chars, int index, int[] cache) {
                            if (index == chars.length) {
                                // 数组都走完了，那返回1，说明当前路径有效
                                return 1;
                            }
                            if (chars[index] == '0') {
                                return 0;
                            }
                            if (cache[index] != -1) {
                                return cache[index];
                            }
                            // 当前总是可以取一个的
                            int ways = processWithCache(chars, index + 1, cache);
                            // 判断是否能取下一个
                            // 当下一个已经到了末尾，那肯定就取不了了
                            if (index + 1 == chars.length) {
                                return ways;
                            }
                            int num = (chars[index] - '0') * 10 + (chars[index + 1] - '0');
                            if (num <= 26) {
                                ways += processWithCache(chars, index + 2, cache);
                            }
                            cache[index] = ways;
                            return ways;
                        }
                    DP
                        public static int numDecodingsDp(String s) {
                            if (s == null || s.length() == 0) {
                                return 0;
                            }
                            char[] chars = s.toCharArray();
                            int[] dp = new int[s.length() + 1];
                            dp[s.length()] = 1;
                            for (int i = dp.length - 2; i >= 0; i--) {
                                if (chars[i] == '0') {
                                    dp[i] = 0;
                                    continue;
                                }
                                dp[i] = dp[i + 1];
                                if (i + 1 == s.length()) {
                                    continue;
                                }
                                int num = (chars[i] - '0') * 10 + (chars[i + 1] - '0');
                                if (num <= 26) {
                                    dp[i] += dp[i + 2];
                                }

                            }
                            System.out.println(Arrays.toString(dp));
                            return dp[0];
                        }
            贴纸问题
                题意
                    给定一个字符串str,给定一个字符串类型的数组arr,出现的字符都是小写英文
                    arr每一个字符串,代表一张贴纸,你可以把单个字符剪开使用,目的是拼出str来
                    返回需要至少多少张贴纸可以完成这个任务
                    eg:
                        str="babac",arr={"ba","c","abcd"}
                        至少需要两张贴纸: "ba"和"abcd",因为使用这两张贴纸,把每一个字符单独剪开,含有2个a,2个b,1个c. 是可以拼出str的,所以返回2
                代码实现
                    暴力递归
                        public static int minStickers(String[] stickers, String target) {
                            if (target == null || target.length() == 0) {
                                return 0;
                            }
                            int result = process(stickers, target);

                            return result == Integer.MAX_VALUE ? -1 : result;
                        }
                        
                        private static int process(String[] stickers, String target) {
                            if (target.length() == 0) {
                                return 0;
                            }
                            int min = Integer.MAX_VALUE;
                            // stickers中每个都试一遍
                            for (String sticker : stickers) {
                                String rest = cut(target, sticker);
                                // 此时剪除有效，也就是里面可以剪去一些东西
                                if (rest.length() != target.length()) {
                                    int nextMin = process(stickers, rest);
                                    if (nextMin != Integer.MAX_VALUE) {
                                        min = Math.min(min, nextMin + 1);
                                    }
                                }
                            }
                            return min;
                        } 

                        private static String cut(String target, String cut) {
                            char[] targetStrs = target.toCharArray();
                            char[] cutStrs = cut.toCharArray();
                            int[] counts = new int[26];
                            for (char c : targetStrs) {
                                counts[c - 'a']++;
                            }
                            for (char c : cutStrs) {
                                counts[c - 'a']--;
                            }
                            StringBuilder stringBuilder = new StringBuilder();
                            for (int i = 0; i < counts.length; i++) {
                                if (counts[i] > 0) {
                                    for (int j = 0; j < counts[i]; j++) {
                                        stringBuilder.append((char) ('a' + i));
                                    }
                                }
                            }
                            return stringBuilder.toString();
                        }
                    暴力递归+缓存优化
                        private static int processWithCache(String[] stickers, String target, HashMap<String, Integer> cache) {
                            if (cache.containsKey(target)) {
                                System.out.println("cache...");
                                return cache.get(target);
                            }
                            if (target.length() == 0) {
                                return 0;
                            }
                            int min = Integer.MAX_VALUE;
                            // stickers中每个都试一遍
                            for (String sticker : stickers) {
                                String rest = cut(target, sticker);
                                // 此时剪除有效，也就是里面可以剪去一些东西
                                if (rest.length() != target.length()) {
                                    int nextMin = processWithCache(stickers, rest, cache);
                                    // 如果返回的值不是Integer.MAX_VALUE，说明是有效的
                                    if (nextMin != Integer.MAX_VALUE) {
                                        min = Math.min(min, nextMin + 1);
                                    }
                                }
                            }
                            cache.put(target, min);
                            return min;
                        }
            最长公共子序列的长度===TODO
                给定两个字符串,求他们的最长公共子序列的长度
                    eg: str1="a12bc345def"  str2="mnp123qrs45z" 他两的最长公共子序列是 "12345" 所以最长公共子序列的长度为5
                代码实现
                    暴力递归 
                        private static int process(char[] strs1, char[] strs2, int i, int j) {
                            if (i == 0 && j == 0) {
                                return strs1[i] == strs2[j] ? 1 : 0;
                            } else if (i == 0) {
                                if (strs1[i] == strs2[j]) {
                                    return 1;
                                } else {
                                    return process(strs1, strs2, i, j - 1);
                                }
                            } else if (j == 0) {
                                if (strs1[i] == strs2[j]) {
                                    return 1;
                                } else {
                                    return process(strs1, strs2, i - 1, j);
                                }
                            } else {
                                int p1 = process(strs1, strs2, i, j - 1);
                                int p2 = process(strs1, strs2, i - 1, j);
                                int p3 = strs1[i] == strs2[j] ? (1 + process(strs1, strs2, i - 1, j - 1)) : 0;
                                return Math.max(p1, Math.max(p2, p3));
                            }
                        }
                    暴力递归+缓存 
                        private static int processWithCache(char[] strs1, char[] strs2, int i, int j, int[][] cache) {
                            if (cache[i][j] != -1) {
                                return cache[i][j];
                            }
                            if (i == 0 && j == 0) {
                                return strs1[i] == strs2[j] ? 1 : 0;
                            } else if (i == 0) {
                                if (strs1[i] == strs2[j]) {
                                    return 1;
                                } else {
                                    return processWithCache(strs1, strs2, i, j - 1, cache);
                                }
                            } else if (j == 0) {
                                if (strs1[i] == strs2[j]) {
                                    return 1;
                                } else {
                                    return processWithCache(strs1, strs2, i - 1, j, cache);
                                }
                            } else {
                                int p1 = processWithCache(strs1, strs2, i, j - 1, cache);
                                int p2 = processWithCache(strs1, strs2, i - 1, j, cache);
                                int p3 = strs1[i] == strs2[j] ? (1 + processWithCache(strs1, strs2, i - 1, j - 1, cache)) : 0;
                                int result = Math.max(p1, Math.max(p2, p3));
                                cache[i][j] = result;
                                return result;
                            }
                        }
                    DP 
                        public static int longestCommonSubsequenceWithDp(String text1, String text2) {
                            if (text1 == null || text1.length() == 0 || text2 == null || text2.length() == 0) {
                                return 0;
                            }
                            char[] strs1 = text1.toCharArray();
                            char[] strs2 = text2.toCharArray();

                            int[][] dp = new int[strs1.length][strs2.length];

                            for (int i = 0; i < strs1.length; i++) {
                                for (int j = 0; j < strs2.length; j++) {
                                    if (i == 0 && j == 0) {
                                        dp[i][j] = strs1[i] == strs2[j] ? 1 : 0;
                                    } else if (i == 0) {
                                        dp[i][j] = strs1[i] == strs2[j] ? 1 : dp[i][j - 1];
                                    } else if (j == 0) {
                                        dp[i][j] = strs1[i] == strs2[j] ? 1 : dp[i - 1][j];
                                    } else {
                                        int p1 = dp[i][j - 1];
                                        int p2 = dp[i - 1][j];
                                        int p3 = strs1[i] == strs2[j] ? (1 + dp[i - 1][j - 1]) : 0;
                                        dp[i][j] = Math.max(p1, Math.max(p2, p3));
                                    }
                                }
                            }
                            return dp[strs1.length - 1][strs2.length - 1];
                        }

            最长回文"子序列"长度
                比如 str="a12b3c43deg2ghi1kpm" 最长回文子序列是"1234321" 或者 "123c321", 返回长度7
                子序列和子串不一样,子序列是可以不连续的,可以分别拆出来再组合(保证顺序不变),子串必须要连续
                思路一
                    一个字符串逆序之后和原字符串的公共子序列,就是最长回文子序列
                    回文啊, 其中一种判断方式就是逆序过来之后和原来的进行对比嘛
                思路二
                    范围尝试模型
                    把结果推到后面去,当前这种情况等同于后面的哪种情况
                    也是分情况讨论

                    建立dp之后还可以继续优化
                            对于两边都不存在的情况,左右是可以继续优化掉的
                        所以为什么要整理严格位置依赖,建立空间感之后可以进一步优化

                    记忆化搜索就是递归缓存,一般暴力递归加了缓存表之后就是最优解了
                leetcode 516
                代码实现
                    暴力递归
                        public static int findLongestPalindromeSubSequenceLengthWithViolenceRecursion(String str) {
                            if (str == null || str.length() == 0) {
                                return 0;
                            }
                            char[] chars = str.toCharArray();
                            return process(chars, 0, chars.length - 1);
                        }
                        public static int process(char[] chars, int left, int right) {
                            // 刚开始肯定不知道怎么找
                            // base case
                            if (left == right) {
                                // 如果最终都走到一个字符了，那这个肯定是个回文字符嘛，长度为1
                                return 1;
                            }
                            if (left == right - 1) {
                                // 如果最后只剩下两个字符，那么判断他两是否相等就可以判断
                                return chars[left] == chars[right] ? 2 : 1;
                            }
                            // 如果都不是上述的情况，那么分情况讨论
                            // 1. 如果最左边的最右边的字符一样，那么最大回文子序列必定包含在left和right之间，长度=2+他两中间那段子串的最大序列长度(left+1,right-1)
                            int res1 = 0;
                            if (chars[left] == chars[right]) {
                                res1 = 2 + process(chars, left + 1, right - 1);
                            }
                            // 如果最左边的字符和最右边的字符不想等，那么最大的要么在左边部分(left~right-1),要么在右边部分(left+1,right)，他两的最大值
                            int res2 = res2 = Math.max(process(chars, left, right - 1), process(chars, left + 1, right));
                            return Math.max(res1, res2);
                        }
                    暴力递归优化
                        public static int processWithCache(char[] chars, int left, int right, int[][] cache) {
                            if (cache[left][right] != 0) {
                                return cache[left][right];
                            }
                            if (left == right) {
                                return 1;
                            }
                            if (left == right - 1) {
                                return chars[left] == chars[right] ? 2 : 1;
                            }
                            int res1 = 0;
                            if (chars[left] == chars[right]) {
                                res1 = 2 + processWithCache(chars, left + 1, right - 1, cache);
                            }
                            // 如果最左边的字符和最右边的字符不想等，那么最大的要么在左边部分(left~right-1),要么在右边部分(left+1,right)，他两的最大值
                            int res2 = res2 = Math.max(processWithCache(chars, left, right - 1, cache), processWithCache(chars, left + 1,
                                    right, cache));
                            int result = Math.max(res1, res2);
                            cache[left][right] = result;
                            return result;
                        }
                    dp
                        public static int processWithDP(String s) {
                            if (s == null || s.length() == 0) {
                                return 0;
                            }
                            char[] chars = s.toCharArray();
                            int length = chars.length;
                            // row->left, col->right
                            int[][] dp = new int[length][length];

                            dp[length - 1][length - 1] = 1;
                            // 构建
                            for (int i = 0; i < dp.length - 1; i++) {
                                // left=right的点都设置值为1
                                dp[i][i] = 1;
                                // left=right-1的位置，如果chars[left]=chars[right] 设置为2 否则为1
                                dp[i][i + 1] = chars[i] == chars[i + 1] ? 2 : 1;
                            }
                            // 数据填充
                            for (int leftIndex = dp.length - 3; leftIndex >= 0; leftIndex--) {
                                for (int rightIndex = leftIndex + 2; rightIndex < dp.length; rightIndex++) {
                                    // 如果chars[left]==chars[right]，取决于(left+1,right-1)
                                    int res1 = chars[leftIndex] == chars[rightIndex] ? (2 + dp[leftIndex + 1][rightIndex - 1]) : 0;
                                    // 还取决于 (left,right-1),(left+1,right)
                                    int res2 = Math.max(dp[leftIndex][rightIndex - 1], dp[leftIndex + 1][rightIndex]);
                                    dp[leftIndex][rightIndex] = Math.max(res1, res2);
                                }
                            }
                            return dp[0][length - 1];
                        }

            象棋问题
                题意
                    请自行搜索/想象一个象棋的棋盘,然后把整个棋盘放入第一象限,棋盘的最左下角是(0,0)的位置,那么整个棋盘就是横坐标上9条线,纵坐标上10条线的区域
                    给定三个参数x,y,k,返回"马"从(0,0)位置出发,必须走K步,最后落在(x,y)上的方法数有多少种?
                暴力递归
                三维动态规划
                    跟机器人差不多,只不过是三维的
                    如果依赖比较复杂,那么就直接通过记忆化搜索(傻缓存)做,不要改成动态规划了
                时间复杂度
                    如果只是单纯地暴力递归,那么时间复杂度就来到了8的k次方
                    二如果三维动态规划了,那么这张三维的表填完,就完事了,10*9*K O(K) 时间复杂度好得多
                代码实现
                    暴力递归
                        public static int horseJumpWithViolenceRecursion(int x, int y, int leftStep) {
                            if (x < 0 || y < 0 || x > 9 || y > 8) {
                                return 0;
                            }
                            return process(x, y, 0, 0, leftStep);
                        }
                        public static int process(int targetX, int targetY, int curX, int curY, int leftStep) {
                            // 数组越界判断
                            if (curX < 0 || curY < 0 || curX > 9 || curY > 8) {
                                return 0;
                            }
                            // base case
                            if (leftStep == 0) {
                                if (targetX == curX && targetY == curY) {
                                    return 1;
                                }
                            }
                            int result = process(targetX, targetY, curX + 1, curY + 2, leftStep - 1) +
                                    process(targetX, targetY, curX + 2, curY + 1, leftStep - 1) +
                                    process(targetX, targetY, curX + 2, curY - 1, leftStep - 1) +
                                    process(targetX, targetY, curX + 1, curY - 2, leftStep - 1) +
                                    process(targetX, targetY, curX - 1, curY - 2, leftStep - 1) +
                                    process(targetX, targetY, curX - 2, curY - 1, leftStep - 1) +
                                    process(targetX, targetY, curX - 2, curY + 1, leftStep - 1) +
                                    process(targetX, targetY, curX - 1, curY + 2, leftStep - 1);
                            return result;
                        }
                    dp
                        public static int processWithDP(int targetX, int targetY, int leftStep) {
                            if (targetX < 0 || targetY < 0 || targetX > 9 || targetY > 8) {
                                return 0;
                            }
                            int[][][] dp = new int[10][9][leftStep + 1];
                            // 将leftStep=0时，targetX=y的位置设置为1
                            dp[targetX][targetY][0] = 1;
                            // 初始化构建
                            for (int x = 0; x < dp.length; x++) {
                                for (int y = 0; y < dp[x].length; y++) {
                                    for (int z = 1; z <= leftStep; z++) {
                                        dp[x][y][z] = pick(dp, x + 1, y + 2, z - 1) +
                                                pick(dp, x + 2, y + 1, z - 1) +
                                                pick(dp, x + 2, y - 1, z - 1) +
                                                pick(dp, x + 1, y - 2, z - 1) +
                                                pick(dp, x - 1, y - 2, z - 1) +
                                                pick(dp, x - 2, y - 1, z - 1) +
                                                pick(dp, x - 2, y + 1, z - 1) +
                                                pick(dp, x - 1, y + 2, z - 1);
                                    }
                                }
                            }
                            return dp[0][0][leftStep];
                        }
            咖啡机问题===TODO 京东难题
                给定一个数组arr,arr[i]代表第i号咖啡机泡一杯咖啡的时间
                给定一个正数N,表示N个人等着咖啡机泡咖啡,每台咖啡机只能轮流泡咖啡

                只有一台洗咖啡的机器,一次只能洗一个杯子,时间耗费a,洗完才能洗下一杯
                每个咖啡杯也可以自己挥发干净,时间耗费b,咖啡机可以并行挥发

                假设所有人拿到咖啡之后立刻喝干净,返回从开始等到所有咖啡机变干净的最短时间
                三个参数: int[] arr,int N,int a,int b

            动态规划空间压缩+为什么要转成"严格依赖表"结构呢? 
                空间压缩(小技巧)---有时间就做,没时间就不做,无伤大雅
                    给定一个二维数组matrix,一个人必须从左上角出发,最后到达右下角,沿途只可以向下或向右走,沿途的数字都累加就是距离累加和,返回最小距离累加和
                        传统动态规划有点浪费空间,存在优化空间的可能性
                        两个数组滚动更新+一个数组自我更新

                    空间压缩扩展,不管什么问题,只要是这样模型的,都可以进行扩展

                    依赖于左,左上,上 。每次搞个临时变量将之前的左上记录下来,因为使用一维数组嘛,那左肯定是在数组中要替换掉左上的
                    那一般来讲,是按照列来压缩(新一维数组的长度就是列的长度)
                        如果数据规模在100w行*3列,那就很爽了
                        但是如果数据规模在3行*100w列,那就真的裂开了
                    所以这个时候,需要按照按照行来进行压缩(新一维数组的长度就是行数),选择行和列中最短的方式嘛,空间可以优化的,两种策略
                    时间复杂度还是一样的,以前传统动态规划需要计算多少还是需要计算多少,但是物理空间变少了
            货币问题1
                题意
                    arr是"货币数组",其中的值都是正数,再给定一个正数aim
                    数组中每一个值都认为是一张货币,即便是值相同的货币也认为是每一张都是不同的,返回组成aim的方法数
                    eg: arr={1,1,1} aim=2, 总共3种方法,返回3
                从左往右模型,index位置的货币要么要,要么不要 
            货币问题2
                题意
                    arr是"面值数组",其中的值都是正数且没有重复,再给定一个正数aim,每个值都认为是一种面值,且认为张数是无限的,返回组成aim的方法数
                    eg: arr={1,2},aim=4 方法如下: 1+1+1+1 1+1+2 2+2 一共就三种方法,所以返回3
                这种情况,转换成 dp表之后,以前设定一个位置的值都是O(1),而这个是需要一个for循环

                记忆化搜索: 依赖关系不强,你之前没算过就去算,算过就直接拿
                严格表依赖,是说整理好严格的依赖关系,从简单位置填到复杂位置,进而求出表中所有位置的元素值的过程,比记忆化搜索进一步地梳理了依赖的关系
                注意⭐️
                    正常来讲,记忆化搜索和严格表依赖的时间复杂度都是表的大小,比如O(N²)/O(N*M)这样
                    
                    如果单独一个格子的值没有枚举行为(也就是没有for循环等),他依赖于有限的位置,那么这两种方式同样好
                    如果有枚举行为(一个格子需要for循环才能算出来),就需要搞出严格表结构之后继续优化了,此时记忆化搜索的效率就没有严格表好了
                        就比如说货币问题2,每一饿单独的格子都要搞一个for循环才能整出答案,这就很deer
                        那就需要进行优化,货币问题2可以通过构建空间感然后观察,将for循环优化成常数时间的复杂度
                代码实现
                    暴力递归 
                        public static int process(int[] arr, int index, int restAim) {
                            if (restAim == 0) {
                                return 1;
                            }
                            if (index == arr.length) {
                                return 0;
                            }
                            int ways = 0;
                            for (int count = 0; count * arr[index] <= restAim; count++) {
                                ways += process(arr, index + 1, restAim - (count * arr[index]));
                            }
                            return ways;
                        }
                    普通DP
                        public static int dp(int[] arr, int restAim) {
                            if (arr == null || arr.length == 0) {
                                return 0;
                            }

                            // 构建数组
                            int[][] dp = new int[arr.length][restAim + 1];

                            // 初始化
                            for (int i = 0; i < arr.length; i++) {
                                dp[i][0] = 1;
                            }
                            for (int i = 1; i <= restAim; i++) {
                                dp[arr.length - 1][i] = 0;
                            }

                            for (int index = arr.length - 2; index >= 0; index++) {
                                for (int col = 1; col <= restAim; col++) {
                                    int ways = 0;
                                    for (int count = 0; arr[index] * count <= col; count++) {
                                        ways += dp[index + 1][col - (count * arr[index])];
                                    }
                                    dp[index][col] = ways;

                                }
                            }
                            return dp[0][restAim];
                        }
                    DP优化
                        public static int dpWithOptimize(int[] arr, int restAim) {
                            if (arr == null || arr.length == 0) {
                                return 0;
                            }
                            // 构建数组
                            int[][] dp = new int[arr.length][restAim + 1];
                            // 初始化
                            for (int i = 0; i < arr.length; i++) {
                                dp[i][0] = 1;
                            }
                            for (int i = 1; i <= restAim; i++) {
                                dp[arr.length - 1][i] = 0;
                            }
                            for (int index = arr.length - 2; index >= 0; index++) {
                                for (int col = 1; col <= restAim; col++) {
                                    dp[index][col] = dp[index + 1][col];
                                    if (restAim - arr[index] > 0) {
                                        dp[index][col] += dp[index][restAim - arr[index]];
                                    }
                                }
                            }
                            return dp[0][restAim];
                        }

            货币问题3
                arr是货币数组,其中的值都是正数.再给定一个正数aim
                每个值都认为是一张货币,认为值相同的货币没有任何不同,返回组成aim的方法数
                eg:arr={1,2,1,1,2,1,2},aim=4 方法: 1+1+1+1,1+1+2,2+2 一共就三种方法,所以返回3
                这道题相对于3就是: 3是说面值相同的是无穷张,这个说的是面值相同的就是有限制,1就是4张,2就是3张
            Bob醉汉生存问题
                题意
                    Bob是一个醉汉,能够走K步,向上下左右走,走完K步 如果超过二维数组(int[K][M])不能存活,问,走K之后存活的概率是多少?
                实现代码(暴力递归)
                    public static long process(int row, int col, int rest, int N, int M) {
                        if (row < 0 || row == N || col < 0 || col == M) {
                            return 0;
                        }
                        if (rest == 0) {
                            return 1;
                        }
                        long up = process(row - 1, col, rest - 1, N, M);
                        long down = process(row + 1, col, rest - 1, N, M);
                        long left = process(row, col - 1, rest - 1, N, M);
                        long right = process(row, col + 1, rest - 1, N, M);

                        long result = up + down + left + right;
                        return result;

                    }

                    public static void main(String[] args) {
                        System.out.println(livingPossibility(1, 1, 1, 1, 1));
                    }
            杀死怪兽
                题意
                    给定3个参数,N,M,K 
                    怪兽有N滴血,等着英雄来砍自己
                    英雄每一次打击,都会让怪兽流失[0~M]的血量,具体流失多少? 每一次在[0~M]上等概率的获得一个值
                    求K次打击之后,英雄把怪兽砍死的概率
                代码实现
                    暴力递归
                        private static long process(int N, int M, int K) {
                            if (K == 0) {
                                return N <= 0 ? 1 : 0;
                            }
                            if (N <= 0) {
                                return (long) Math.pow(M + 1, K);
                            }
                            long ways = 0;
                            for (int i = 0; i <= M; i++) {
                                ways += process(N - i, M, K - 1);
                            }
                            return ways;
                        }
                    普通动态规划 
                        public static double killMonsterDp1(int N, int M, int K) {
                            if (N < 1 || M < 1 || K < 1) {
                                return 0;
                            }
                            long all = (long) Math.pow((M + 1), K);
                            long[][] dp = new long[K + 1][N - 1];
                            dp[0][0] = 1;
                            for (int times = 1; times <= K; times++) {
                                dp[times][0] = (long) Math.pow(M + 1, times);
                                for (int hp = 1; hp <= N; hp++) {
                                    long ways = 0;
                                    for (int i = 0; i < M; i++) {
                                        if (hp - i >= 0) {
                                            ways += dp[times - 1][hp - i];
                                        } else {
                                            ways += (long) Math.pow(M + 1, times - 1);
                                        }
                                    }
                                    dp[times][hp] = ways;
                                }
                            }
                            long killTimes = dp[K][N];
                            return (double) ((double) killTimes / (double) all);
                        }
                    动态规划---斜率优化(建立空间感,观察DP表得来的)
                        public static double killMonsterDp2(int N, int M, int K) {
                            if (N < 1 || M < 1 || K < 1) {
                                return 0;
                            }
                            long all = (long) Math.pow((M + 1), K);
                            long[][] dp = new long[K + 1][N - 1];
                            dp[0][0] = 1;
                            for (int times = 1; times <= K; times++) {
                                dp[times][0] = (long) Math.pow(M + 1, times);
                                for (int hp = 1; hp <= N; hp++) {
                                    dp[times][hp] = dp[times][hp - 1] + dp[times - 1][hp];
                                    if (hp - M - 1 >= 0) {
                                        dp[times][hp] -= dp[times - 1][hp - M - 1];
                                    } else {
                                        dp[times][hp] -= Math.pow(M + 1, times - 1);
                                    }
                                }
                            }
                            long killTimes = dp[K][N];
                            return (double) ((double) killTimes / (double) all);
                        }
            货币问题无限制最小货币数
                题意
                    arr是面值数组,其中的值都是正数且没有重复. 再给定一个正数aim. 
                    每个值都认为是一种面值,且认为张数是无限的.
                    返回组成aim的最少货币数
                代码实现
                    暴力递归 
                        // 返回最少需要多少张
                        private static int process(int[] arr, int index, int rest) {
                            if (index == arr.length) {
                                return rest == 0 ? 0 : Integer.MAX_VALUE;
                            }
                            int min = Integer.MAX_VALUE;
                            // 下面正常情况,计算此时需要的数量
                            for (int count = 0; arr[index] * count <= rest; count++) {
                                // 当当前下标位置的货币取count张时，看看下一个下标位置(index+1)开始，rest-arr[index]*count 最少需要多少张货币
                                int nextMin = process(arr, index + 1, rest - arr[index] * count);
                                // 如果当前这种情况可以组成aim，也就是下一个不返回Integer.MAX_VALUE,那就比对当前的和下一个最小的
                                // 如果返回的值不是Integer.MAX_VALUE，说明是有效的
                                if (nextMin != Integer.MAX_VALUE) {
                                    min = Math.min(min, nextMin + count);
                                }
                            }
                            return min;
                        }
                    普通DP
                        public static int minCoinsDp1(int[] arr, int aim) {
                            if (arr == null || arr.length == 0 || aim == 0) {
                                return 0;
                            }
                            int[][] dp = new int[arr.length + 1][aim + 1];
                            // 初始化边界值
                            dp[arr.length][0] = 0;
                            for (int i = 1; i <= aim; i++) {
                                dp[arr.length][i] = Integer.MAX_VALUE;
                            }

                            // 依赖 [index+1][rest-arr[index]*count] ，所以是从下往上填
                            for (int index = arr.length - 1; index >= 0; index--) {
                                for (int rest = 0; rest <= aim; rest++) {
                                    int min = Integer.MAX_VALUE;
                                    for (int count = 0; arr[index] * count <= rest; count++) {
                                        int nextMin = dp[index + 1][rest - arr[index] * count];
                                        if (nextMin != Integer.MAX_VALUE) {
                                            min = Math.min(min, nextMin + count);
                                        }
                                    }
                                    dp[index][rest] = min;
                                }
                            }
                            return dp[0][aim];
                        }
                    DP---斜率优化
                        public static int minCoinsDp2(int[] arr, int aim) {
                            if (arr == null || arr.length == 0 || aim == 0) {
                                return 0;
                            }
                            int[][] dp = new int[arr.length + 1][aim + 1];
                            // 初始化边界值
                            dp[arr.length][0] = 0;
                            for (int i = 1; i <= aim; i++) {
                                dp[arr.length][i] = Integer.MAX_VALUE;
                            }

                            // 依赖 [index+1][rest-arr[index]*count] ，所以是从下往上填
                            for (int index = arr.length - 1; index >= 0; index--) {
                                for (int rest = 0; rest <= aim; rest++) {
                                    dp[index][rest] = dp[index + 1][rest];
                                    if (rest - arr[index] >= 0 && dp[index][rest - arr[index]] != Integer.MAX_VALUE) {
                                        dp[index][rest] = Math.min(dp[index][rest - arr[index]] + 1, dp[index][rest]);
                                    }
                                }
                            }
                            return dp[0][aim];
                        }
            较小集合累加和
                题意
                    给定一个正数数组arr
                    请把arr中所有的数分为两个集合,尽量让两个集合的累加和接近
                    返回: 最接近的情况下,两个集合中较小集合的累加和
                代码实现(数组的sum/2,然后求出最接近且不超过这个middleSum的最大累加和)
                    暴力递归 
                        public static int splitSumClosed(int[] arr) {
                            if (arr == null || arr.length < 2) {
                                return 0;
                            }
                            int sum = 0;
                            for (int num : arr) {
                                sum += num;
                            }
                            return process(arr, 0, sum / 2);
                        }
                        private static int process(int[] arr, int index, int rest) {
                            if (index == arr.length) {
                                return 0;
                            }
                            // 不要当前元素,看下一个位置(index+1)，rest不变
                            int p1 = process(arr, index + 1, rest);
                            // 要当前元素
                            int p2 = 0;
                            if (arr[index] <= rest) {
                                p2 = arr[index] + process(arr, index + 1, rest - arr[index]);
                            }
                            int result = Math.max(p1, p2);

                            return result;
                        }
                    动态规划 
                        public static int splitSumWithDP(int[] arr) {
                            if (arr == null || arr.length < 2) {
                                return 0;
                            }
                            int sum = 0;
                            for (int num : arr) {
                                sum += num;
                            }
                            int middleSum = sum / 2;
                            int[][] dp = new int[arr.length+1][middleSum + 1];
                            for (int index = arr.length - 1; index >= 0; index--) {
                                for (int rest = 0; rest <= middleSum; rest++) {
                                    int p1 = dp[index + 1][rest];
                                    int p2 = 0;
                                    if (arr[index] <= rest) {
                                        p2 = arr[index] + dp[index + 1][rest - arr[index]];
                                    }
                                    dp[index][rest] = Math.max(p1, p2);
                                }
                            }
                            return dp[0][middleSum];
                        }
            较小集合累加和---长度限制
                题意
                    给定一个正数数组arr,请把arr中所有的数分为两个集合
                        如果arr长度为偶数,两个集合包含数的个数要一样多
                        如果arr长度为奇数,两个集合包含的数的个数必须只差一个
                    请尽量让两个集合的累加和接近
                    返回: 最接近的情况下,较小集合的累加和
                代码实现
                    暴力递归 
                        public static int splitSumClosedHalfSize(int[] arr) {
                            if (arr == null || arr.length == 0) {
                                return 0;
                            }
                            int sum = 0;
                            for (int num : arr) {
                                sum += num;
                            }
                            int middleSum = sum / 2;
                            if ((arr.length & 1) == 0) {
                                // 长度为偶数
                                return process(arr, 0, middleSum, arr.length / 2);
                            } else {
                                // 长度为奇数
                                return Math.max(process(arr, 0, middleSum, arr.length / 2), process(arr, 0, middleSum, arr.length / 2 + 1));
                            }
                        }
                        private static int process(int[] arr, int index, int rest, int leftCount) {
                            if (index == arr.length) {
                                // 如果leftCount不为0，那肯定是个无效解
                                return leftCount == 0 ? 0 : -1;
                            } else {
                                // 当前下标位置的元素不要
                                int p1 = process(arr, index + 1, rest, leftCount);
                                int p2 = -1;
                                int next = -1;
                                if (rest - arr[index] >= 0) {
                                    next = process(arr, index + 1, rest - arr[index], leftCount - 1);
                                }
                                if (next != -1) {
                                    p2 = arr[index] + next;
                                }
                                int result = Math.max(p1, p2);
                                return result;
                            }
                        }

                        // 从index位置开始，还剩余leftCount个元素可以用，并且累加和<=rest 的最大累加和是多少
                        private static int myProcess(int[] arr, int index, int rest, int leftCount) {
                            if (index == arr.length) {
                                return 0;
                            }
                            // 如果都没有可以用的个数了，此时累加和肯定返回0
                            if (leftCount == 0) {
                                return 0;
                            }
                            // 当前这个位置不要
                            int p1 = process(arr, index + 1, rest, leftCount);

                            // 当前位置不要
                            int p2 = 0;
                            if (rest - arr[index] >= 0) {
                                p2 = arr[index] + process(arr, index + 1, rest - arr[index], leftCount - 1);
                            }
                            int result = Math.max(p1, p2);
                            return result;
                        }

            N皇后问题===TODO

        斜率优化
            只有求一个位置的元素用到了枚举的时候才能进行斜率优化

        模型
            从左往右尝试模型
                当前位置的值要么就要,要么就不要
            范围尝试模型
                纸牌游戏
                特别在意样本的开头和结尾共同结合的可能性
                最长回文"子序列"长度
            样本对应模型
                最长公共子序列长度
                    结尾处,两个都要还是要其中一个,都要的时候,是有条件的
                "特别在意两个样本结尾如何如何"⭐️⭐️⭐️
                一般是两个样本比对
                杀死怪兽    
                    
                象棋
            业务限制模型
        原则
            1. 每一个可变参数的类型,一定不要比int类型更加复杂
                eg: 数组类型/字符串类型作为可变参数
            2. 原则1可以违反,但是必须是单一可变参数
                eg: 贴纸问题,只有一个字符串类型的可变参数
            3. 如果原则1被违反,但是不违反原则2,做到记忆化搜索即可(暴力递归+缓存)
            4. 可变参数的个数能少就少

            尝试暴力递归的时候,一定不要破坏原则
        总结
            什么样的暴力递归可以优化? 出现重复解的暴力递归可以优化
                如果一个暴力递归每一个子结果都是不一样的,那么就不用优化也不能优化
                优化也是从可变参数入手,然后生成一个动态规划表

            动态规划的目的就是防止我展开之后,你展开还出现一样的值就不要去算了,就直接拿值就行,可能就是为了优化暴力递归
                而如果每个子过程的结果都不一样,动态规划是无法优化这样的暴力递归的

            优化就是看依赖,看递归函数的依赖的值,看看是否有利可图

            只要写出暴力递归,就可以很容易的转成动态规划
                就是看依赖嘛,然后根据依赖的情况去改
        
    窗口内最大值或最小值的"更新结构"
        滑动窗口
            滑动窗口是一种想象出来的数据结构,滑动窗口有左边界L和右边界R,L和R在任何时刻都可以往右边滑动,且只能往右边滑动,要保证L不超过R的原则
                没说是R往右移动L就要往右移动啊,R右移L可以不动...
            如何快速得到一个窗口的最大值呢? 
                就是R和L都在往右移动,那每次窗口都会进行更新嘛,那每次更新了之后如何得到这次更新之后的最大值呢? 
                    是,可以每次更新之后去循环遍历一下,然后得到这个窗口数组内的最大值,但是这就很deer了嘛,每更新一次都要去遍历
                    有没有一种结果可以做到快速更新呢? 当有新元素进入到窗口/元素出窗口,就能迅速更新他的值,时间复杂度降低
        双端队列实现更新结构
            双端队列的头/尾弹出节点的时间复杂度都是O(1)

            窗口新增元素过程(R++)
                规定双端队列从头到尾是按照从大到小的顺序进行排列的,那么每次滑动窗口中新进一个元素,比对队尾元素,如果比队尾元素小,就直接将他们依次从尾部放入队列中,如果>=队尾元素,那么弹出队尾元素,然后再进行比对,还是>=队尾,那就继续弹出,直至找到比当前元素小的或者队列为空,从队尾压进去
            窗口缩小减少元素过程(L--)
                缩小窗口的时候,就直接去比对当前值和窗口中最大值(队头元素的值+"下标"),如果下标不一样且值比队头元素小,那就直接缩小,如果下标与值和队头元素一样,那就缩小并且将双端队列中的对应元素(队头元素)弹出去

                直接去比对队列中的队头元素下标是否过期,如果已经过期,就直接把队头元素也弹出去嘛,然后窗口缩小,不用管队头元素的值怎么样,就只看是否过期
            这样就能保证每次缩小窗口的时候,队列中的队头元素就是当前窗口的最大值

            双端队列中存放元素的(下标+值)

            含义
                如果依次让窗口缩小的话(只能通过L++的方式缩小窗口,R不能--,他不能回退往左移),哪些数会依次成为窗口内的最大值
                为啥队列中比当前元素小的值,直接弹出呢? 因为这个时候当前元素的有效期(只能L++嘛,队列里面的元素都是当前元素左边的嘛,所以有效期会比较长一点)肯定比队列中的这个小值长,而他的值又比队列中的大,那肯定在这个有效期内,当前元素的值就是最大的,所以队列中的元素直接弹出,保留没有意义啊

                如果当前元素>=队列中的值,就直接把队列中的弹出去
            好在哪呢? 优势
                假设有一个数组,要使用窗口L和R要滑过数组中所有的数的话,那么每个位置的元素,最多进一次队列,最多出一次队列,窗口在运动的过程中,双端队列更新的总代价就是2N嘛,时间复杂度就是O(N)
        题目
            假设一个固定大小为W的窗口,依次滑过arr,返回每一次滑出状况的最大值---每年都出现?
                例如 arr=[4,3,5,4,3,3,6,7],W=3,返回:[5,5,5,4,6,7]
                    双端队列中存放下标
                代码实现
                public static int[] slidingMax(int[] arr, int windowSize) {
                    // base case
                    if (arr == null || windowSize > arr.length || windowSize < 1) {
                        return null;
                    }
                    // 双端队列,队列中存储的是下标
                    LinkedList<Integer> queue = new LinkedList<>();
                    // 结果集
                    int[] resultArr = new int[arr.length - windowSize + 1];
                    int resultIndex = 0;

                    // 窗口的起始位置,假如结束位置索引是endIndex,起始位置的索引就是startIndex=endIndex-windowSize+1
                    for (int rightIndex = 0; rightIndex < arr.length; rightIndex++) {
                        // 弹出队列中比当前值小的元素
                        while (!queue.isEmpty() && arr[queue.peekLast()] <= arr[rightIndex]) {
                            queue.pollLast();
                        }
                        // 将当前值加入到队列中
                        queue.addLast(rightIndex);
                        // 判断过期,窗口的最左边元素的下标是否是队头元素嘛，如果是的话，那就直接过期
                        int leftIndex = rightIndex - windowSize + 1;
                        // 上一次的leftIndex
                        if (!queue.isEmpty() && (rightIndex - windowSize) == queue.peekFirst()) {
                            // 直接弹出
                            queue.pollFirst();
                        }
                        // 如果形成了一个窗口
                        if (leftIndex >= 0) {
                            // 将当前结果加入到结果集中
                            resultArr[resultIndex++] = arr[queue.peekFirst()];
                        }
                    }
                    return resultArr;
                }
                public static int[] myWay(int[] arr, int windowSize) {

                    if (arr == null || arr.length == 0 || windowSize < 1 || arr.length < windowSize) {
                        return null;
                    }
                    // 双端队列
                    LinkedList<Integer> queue = new LinkedList<>();
                    // 结果集
                    int[] resultArr = new int[arr.length - windowSize + 1];
                    int resultIndex = 0;
                    // 将第一个存入队列中
                    queue.addLast(0);

                    // 先形成窗口大小
                    for (int i = 0; i < windowSize; i++) {
                        while (!queue.isEmpty() && arr[queue.peekLast()] <= arr[i]) {
                            queue.pollLast();
                        }
                        queue.add(i);
                    }
                    // 此时窗口中最大的结果加入到结果集中
                    resultArr[resultIndex++] = arr[queue.peekFirst()];
                    // 此时窗口形成
                    for (int rightIndex = windowSize; rightIndex < arr.length; rightIndex++) {
                        // 判断当前是否>=队列中元素
                        while (!queue.isEmpty() && arr[queue.peekLast()] <= arr[rightIndex]) {
                            // 一直弹出
                            queue.pollLast();
                        }
                        // 将元素加入到队列中
                        queue.addLast(rightIndex);
                        // 此时左边界准备向右移动
                        // 判断此时还未移动的左边界是否会过期
                        int beforeLeftIndex = rightIndex - windowSize;
                        if (beforeLeftIndex == queue.peekFirst()) {
                            // 如果真是，那么就弹出队头元素
                            queue.pollFirst();
                        }
                        // 这个时候，队列中剩下的队头元素，就是当前窗口的最大值，加入到结果集中
                        resultArr[resultIndex++] = arr[queue.peekFirst()];
                    }
                    return resultArr;
                }
            给定一个整数数组arr,和一个整数num,某个arr中的子数组sub,如果想达标,必须满足: sub中最大值-sub中最小值<=num,返回arr中达标子数组的数量
                一个子数组达标之后,它里面所有的子数组也必定全部达标
                一个子数组(L...R)不达标之后,那么L往左扩,或者R往右扩,那必定也不达标
                    因为最大值和最小值已经不达标了,往左扩/往右扩,它新增的最大值/最小值要么不超过,要么超过,超过了那肯定不达标嘛
                不能直接使用N*(N+1)/2,防止重复计算

                思路
                    记录从0开始,以0开始的达标的子数组有多少个,记录以1开始,以0开始的达标的子数组有多少个
                    搞两个双端队列,一个记录最大值,一个记录最小值,从0开始,窗口往后扩,一直扩,直到扩到不达标为止,(不达标了,再往后扩也没意义),然后统计当前只"以0开头的子数组"有多少,记录下来保存到结果集中,这是第一轮,第二轮从1开始......
            加油站的良好出发问题
            货币问题 
            arr是货币数组,其中的值都是正数.再给定一个正数aim,每个值都认为是一张货币,返回组成aim的最少货币数

        窗口问题怎么想到
            思路和窗口移动轨迹(开头和结尾是否不回退)是否拥有相似性,找到相似性之后,如何跟窗口的最大值和最小值靠
        
    单调栈⭐️⭐️⭐️
        概述+适用场景
            给定一个数组,有个需求用来保存这个数组中每个元素的左边离他最近的比他小的元素+右边离他最近的比他小的元素
            如果是传统方式进行求解,那么每次都要去找一个特定位置的元素左边比他小的,或者右边比他小的离得最近的,都需要通过遍历才能使心啊,那就是O(N²),很麻烦

            现在就说,能不能生成每个位置的左边+右边比他小的最近的值,同时还保证时间复杂度为O(N),怎么实现? 单调栈就是解决这个问题的
        流程(时间复杂度O(N))
            没有重复值
                将数组中所有的相关信息统计出来保存,给定一个数组

                搞一个栈(栈中的元素要按照从下而上从小到大的顺序存放),然后遍历数组,遍历到一个值之后,去栈中看,第一次肯定栈为空嘛,直接存进去,然后以后的元素,遍历到的时候去看栈顶元素,如果比栈顶元素小,那么从栈中弹出它,生成它的信息,右边离的最近的比这个栈顶元素小的就是当前遍历到的这个元素,而离的最近的比这个栈顶元素小的左边的元素就是此时栈中顶部元素,生成好之后,再接着将遍历到的元素又和栈中的顶部元素对比,如果还是比栈顶元素小,那么就继续操作,直至比栈顶元素大,压入栈中... 
                数组遍历完成之后,那么此时将最后一个元素压入栈中,栈还不是空的,就去弹栈,弹出来的第一个元素肯定,左边就是下一个元素嘛(没有就设置为null/-1),右边肯定没有,他都是最后一个元素了,如果栈中还有元素的话,那它的信息就是左边null/-1右边null/-1了
                
                存的是普通的数据/"索引"
            有重复值
                大体上的操作过程跟上面一样,但是在栈中存储的数据就不一样了,存数据的时候是存索引组成的链表,一旦发现值相同了但是索引不同,那么将索引添加到此时栈顶元素的链表中,值不变,后续操作一样,那么在弹出的时候,对练表中的索引都要进行设置左右信息

                为啥存链表而不是数组,存数组你咋知道数组开多大空间啊? 如果初始空间没设置好,后期还要扩容

                注意啊
                    如果有多个重复的,比如栈顶中的链表中有3个值,他下一个层的链表中也有3个值,那么栈顶元素弹出的时候,他右边肯定没有嘛,左边的就要设置为下一层的链表中最后一个元素
                    
                    如果数组遍历完之后,栈中还有元素,那么栈顶的元素右边设置为null/-1,左边就设置为下一层链表的最后一个元素,而他下一层的左右都设置为null

                    比如说 1 17 200 为什么他三会在一起,那肯定是1~17之间的值都被17释放掉了,17存进来了, 17~200之间的值也都200被释放掉了,然后200存进来了
        为什么
            左边: 左边元素压入栈顶之后,那第一个比他大的肯定也直接压进去了,所以左边离当前栈顶元素最近的肯定就是他在栈中下一个位置
                如果中间比a大,那肯定就那啥了
            右边: 遇到比栈顶元素小的,就说明遍历到的这个元素是右边离栈顶元素最近的,右边能遇到比栈顶元素小的,那必定是离他最近的,第一个才会先过来嘛 
                中间如果有比他小的,那肯定就那啥了嘛
        实现
            无重复的实现
                代码实现
                    public static int[][] getNearestLessWithoutRepeat(int[] arr) {
                        if (arr == null || arr.length == 0) {
                            return null;
                        }
                        // 初始化结果集
                        int[][] resultArr = new int[arr.length][2];
                        // 单调栈,里面存放元素在原数组中对应的下标
                        Stack<Integer> monotoneStack = new Stack<>();

                        for (int i = 0; i < arr.length; i++) {
                            // 一直去比对，看看能不能进栈，如果不行就一直让栈中元素弹出
                            while (!monotoneStack.isEmpty() && arr[monotoneStack.peek()] > arr[i]) {
                                // 此时需要进行操作
                                Integer index = monotoneStack.pop();
                                resultArr[index][1] = i;
                                resultArr[index][0] = monotoneStack.isEmpty() ? -1 : monotoneStack.peek();
                            }
                            monotoneStack.push(i);
                        }
                        // 都走完了，最后栈中剩下的就是最后几个元素，将栈清空
                        while (!monotoneStack.isEmpty()) {
                            Integer index = monotoneStack.pop();
                            resultArr[index][1] = -1;
                            resultArr[index][0] = monotoneStack.isEmpty() ? -1 : monotoneStack.peek();
                        }
                        return resultArr;
                    }
            有重复的实现
                为啥使用arraylist,因为有涉及到去拿链表中最后一个元素,也就是按照链表长度-1作为下标去拿,那么这里实际上就是取下标嘛,那肯定arraylist快啊,如果使用linkedlist底层链表,每次都需要遍历一遍才拿得到
                代码实现
                    public static int[][] getNearestLess(int[] arr) {
                        if (arr == null || arr.length == 0) {
                            return null;
                        }
                        // 因为数组中可能有重复值出现，所以栈中存放链表结构
                        Stack<List<Integer>> monotoneStack = new Stack<>();
                        // 结果集
                        int[][] resultArr = new int[arr.length][2];

                        for (int i = 0; i < arr.length; i++) {
                            // 将当前元素存入栈中,每次默认取栈顶元素的第一个位置的值
                            while (!monotoneStack.isEmpty() && arr[monotoneStack.peek().get(0)] > arr[i]) {
                                // 弹出栈顶元素，并进行设置
                                List<Integer> indexList = monotoneStack.pop();
                                int leftIndex = monotoneStack.isEmpty() ? -1 : monotoneStack.peek().get(monotoneStack.peek().size() - 1);
                                for (Integer index : indexList) {
                                    resultArr[index][0] = leftIndex;
                                    resultArr[index][1] = i;
                                }
                            }
                            // 判断是否相等
                            if (!monotoneStack.isEmpty() && arr[monotoneStack.peek().get(0)] == arr[i]) {
                                // 直接在链表后面加一个就行
                                monotoneStack.peek().add(i);
                            } else {
                                // 此时单调栈中的元素就是小于当前元素嘛，直接新建一个链表压入栈中
                                List<Integer> newList = new ArrayList<>();
                                newList.add(i);
                                monotoneStack.push(newList);
                            }
                        }
                        // 所有元素遍历完成，清空栈
                        while (!monotoneStack.isEmpty()) {
                            List<Integer> indexList = monotoneStack.pop();
                            int leftIndex = monotoneStack.isEmpty() ? -1 : monotoneStack.peek().get(monotoneStack.peek().size() - 1);
                            for (Integer index : indexList) {
                                resultArr[index][0] = leftIndex;
                                resultArr[index][1] = -1;
                            }
                        }
                        return resultArr;
                    }
        题目
            给定一个"只包含正数"的数组arr,arr中任何一个子数组sub,一定都可以算出(sub累加和)*(sub中的最小值)作为"指标"是什么,那么所有子数组中,这个值最大是多少?
                思路
                    遍历数组,每遍历一个元素,求出以他作为最小值的子数组有哪些,然后求这些子数组的指标,然后呢遍历一遍下来求出最大的那个
                    然后sub中最小值就确定了x,要使得指标最大,指标=sum*min,min确定了,那就是求这个范围上sum最大嘛
                        假设左边离x最近的比他小的记为i,右边离x最近的比他小的记为k,那么sum最大值=i~k内的累加和
                        为啥呢,因为那很明显,i位置到x位置中间自然都是比x大的,k位置到x中间也都是比x位置大的,那这个区间的累加和,肯定可以保证sum最大的

                    那也就是遍历数组中每一个元素,然后假定他们就是当前子数组中最小的,然后根据它去求的sum最大,sum什么时候最大呢,i和k位置中间的值进行相加,就是最大,因为在这中间的数都是比x大的,只有正数啊,所以不会存在范围大,但是累加和较小的情况
                    i~k的累加和用O(1)实现---不用遍历的方式
                        生成一个前缀和数组(预处理),比如arr数组[3,2,1,7]的前缀和数组newArr就是[3,5,6,13],然后呢加入我要求1~3位置的sum和,那就是newArr[3]-newArr[1-1],又比如说我要求2~3下标位置的sum和,那就是newArr[3]-newArr[2-1]
                    算的时候,遇到重复的相同的值,也直接把它当作一个比本身小的值直接算,虽然刚开始一些算出来的结果不正确,但是最后一个重复值会对
                    或者也可以直接放小链表,麻烦一点嘛
                代码实现
                    private static int[] getPrefixSumArr(int[] arr) {
                        if (arr == null || arr.length == 0) {
                            return null;
                        }
                        int[] prefixSumArr = new int[arr.length];
                        int sum = 0;
                        for (int i = 0; i < arr.length; i++) {
                            sum += arr[i];
                            prefixSumArr[i] = sum;
                        }
                        return prefixSumArr;
                    }
                    public static int maxTarget(int[] arr) {
                        if (arr == null || arr.length == 0) {
                            return 0;
                        }
                        int[][] nearestLessInfo = getNearestLess(arr);
                        int maxTarget = Integer.MIN_VALUE;
                        int[] prefixSumArr = getPrefixSumArr(arr);

                        for (int i = 0; i < arr.length; i++) {
                            // 获取累加和需要用到前缀和来降低时间复杂度，O(1)
                            // TODO 校验 不确定是不是这样的
                            // 如果左侧比他小的是-1，说明左侧全都比当前值大，那么最左边的索引就是-1，但是在算前缀和的时候，如果是这种情况，再运算的时候就不需要减去左边的前缀和
                            int leftIndex = nearestLessInfo[i][0];
                            // 如果右侧比他小的为-1，说明右侧全都比当前值大，那么最右边的索引就设置为arr.length
                            int rightIndex = nearestLessInfo[i][1] == -1 ? arr.length : nearestLessInfo[i][1];
                            int sum = leftIndex == -1 ? prefixSumArr[rightIndex - 1] :
                                    (prefixSumArr[rightIndex - 1] - prefixSumArr[leftIndex]);
                            maxTarget = Math.max(maxTarget, sum * arr[i]);
                        }
                        return maxTarget;
                    }
            给定一个非负数组arr,代表直方图📊,返回直方图的最大长方形面积,要以最小的为基准
                思路
                    以自己的高度为准,看看能扩多远(求不比它自身小的范围)
                        假设自己的高度最小,然后去往左右两边扩,看看不比自己小的范围是多少,然后呢这个范围之内就可以求出以自一个最大值嘛,每一个都如此,那最后最大长方形面积就求出来了
                        相等的跟处理比自己小的时候一样的
                实现代码
                    public static int getMatrixMaxArea(int[] arr) {
                        if (arr == null || arr.length == 0) {
                            return 0;
                        }
                        int[][] nearestLessInfo = getNearestLess(arr);
                        int maxArea = Integer.MIN_VALUE;
                        for (int i = 0; i < arr.length; i++) {
                            int leftIndex = nearestLessInfo[i][0];
                            int rightIndex = nearestLessInfo[i][1] == -1 ? arr.length : nearestLessInfo[i][1];
                            maxArea = Math.max(maxArea, arr[i] * ((rightIndex - 1) - leftIndex));
                        }
                        return maxArea;
                    }
            给定一个二维数组matrix,其中的值不是0就是1,返回全部由1组成的最大子矩阵,内部有多少个1
                一个n*n的矩阵中,他的子矩阵是n的四次方数量级
                    我随便点一个点,有 n²种可能,再点一个点,也有n²种可能,两个点就可以确定一个矩阵,那么就是n的四次方
                最优解可以干到O(n²)
                思路 
                    依次以每一行数据作为地基,搞出他的直方图📊,求当前这个直方图中最大的矩阵,一直走走走,走到最后一行,以最后一行作为地基,求,然后综上整合最大的那个结果就行

                    每一行与之前的地基相加,如果当前某个位置是0,那么就没有高度
                    这个就是压缩数组技巧了
            给定一个二维数组matrix,其中的值不是0就是1,返回全部由1组成的子矩阵数量
    求斐波拉契数列矩阵乘法的方法===TODO
        没有条件转移(每一项的求值条件都是一样的)的严格递推式都有log(n)的方法求出来
            比如说斐波拉契数列f(n)=f(n-1)+f(n-2),他每一项的求值条件和规律都是一样的,且终止位置
                f(n)依赖f(n-1)h额f和f(n-2)是个严格关系
            就是中途没有多余的if...else之类的判断,比较单纯的规律,那都有log(n)的方法进行求解
    KMP算法(字符串匹配优化算法)
        概述
            KMP三个人名首字母缩写 M就是Morris
            是一种字符串的查找/匹配算法,改进后的字符串匹配算法
                eg: s1="abc123" s2="123" 求s1中能够匹配s2的子串的起始位置,返回3,如果有多个,就返回第一个
        传统字符串匹配方式
            就是一个一个扫
            那么最坏的情况就像是:s1="aaaaab" s2="aaab" ,加入s1的长度为N,s2的长度为M,那么这个的时间复杂度就是O(N*M)
            为什么会这么暴力呢? 就是前面的扫描/验证过程相对于后续的扫描/验证是独立的,没有为后续提供参考,所以很慢很暴力
        KMP就可以做到时间复杂度为O(N)
        前缀和后缀和最大相等长度---next信息
            eg
                abcabck,比如k这个字符位置,他的这个信息是多少呢? 3
                    前缀串和后缀串相等,且不能取到整体(abcabc)这个情况下最长的长度是多少(前缀串为abc(012),后缀串也为abc(345)的情况下,前缀串和后缀串相等,abc的长度为3,所以k的信息就是3)
                aaaaak,k字符位置,信息是4(前缀串和后缀串相等时的最长长度,但是不包括aaaaa整体)
            
            字符串中每一个字符都有一个这样的信息,组成一个"next数组",这个next数组可以让我们的"匹配过程"加速,任何字符串,第0个下标的时候,这个值为-1,第一个下标的位置值为0

            一般判断s1中是否包含s2,那么就让s2算出一个next数组
        next数组如何加速匹配速度呢?
            s2搞一个next数组,然后s1去进行匹配,当从s1的i位置开始匹配,匹配到s1的x下标时,发现匹配失败,那么这个时候x对应s2中的y下标,那么就根据y的next信息,往后推,推了之后再去检查新推之后的那个元素,如果相等,那就去看新推的之后的那个长度,如果不等,那就继续新推
            周而复始,直至那啥不能搞为止

            判断当前匹配出错的这个字符之前在字符串中有没有出现过,是不是前缀和+后缀和中公共的字符,如果不是,那么只有往后走去遍历查看了
        为啥可以直接跳相等长度呢? 为啥中间不用证明呢?

            世界上就是跳next数组中对应的下标位置,然后s1匹配失败的那个元素去和s2中匹配失败的字符对应的next中的信息/下标的值进行比对,一直跳跳跳,如果跳到最后一个还是比对不上,那s1那个元素就往后移动,下一个位置再和这个新跳的进行比对
        只要某一个字符不匹配了,那么s2的下标索引就会往前移动,往哪移动(算出来next数组中对应的值(吧这个值当作下标)去移动)

        总的来讲,就是按照字符串匹配嘛,kmp只是优化一下,比对的逻辑一个一个字符比对肯定不变,当不匹配的时候,这个时候s2的y下标需要向左移动(移动到next数组中记录的下标位置),那怎么个移动呢?  正常情况直接移动,但是要判断一下当前的y是不是在0位置了,在0位置了说明再也不能移动了嘛,所以这个要判断一下,只有不是在0位置的时候才能移动


        求next数组
            从左向右,0下标设置为-1,1下标设置为0,当前位置的下标要根据前一个位置的信息获取,设定前一个位置的信息是x
                如果在x下标的"值"如果和"前一个元素的字符"相等,那么当前位置的信息="前一个位置的信息"+1(不可能更长了)
                如果在x下标的"值"和"前一个元素的字符"不想等,那么就去看x下标的信息,假设是y,那么看y下标的值和"前一个元素的字符"是否相等,如果相等,那就是x下标的信息+1,如果不等,那继续往前推
        代码实现
            private static int[] getNextArr(char[] str) {
                if (str.length == 1) {
                    return new int[]{-1};
                }
                int[] next = new int[str.length];

                next[0] = -1;
                next[1] = 0;
                int index = 2;
                int cn = 0;
                while (index < next.length) {
                    if (str[index - 1] == str[cn]) {
                        next[index] = ++cn;
                    } else if (cn > 0) {
                        cn = next[cn];
                    } else {
                        next[index++] = 0;
                    }
                }
                return next;
            }
            public static int kmpMatch(String s1, String s2) {
                if (s1 == null || s1.length() == 0 || s2 == null || s2.length() == 0 || s1.length() < s2.length()) {
                    return -1;
                }
                char[] chars1 = s1.toCharArray();
                char[] chars2 = s2.toCharArray();
                int x = 0;
                int y = 0;
                // 时间复杂度O(M) M是要进行匹配的字符串长度 M<=N
                int[] next = getNextArr(chars2);
                // 时间复杂度 O(N) N是s1的长度，s2的长度<=s1的长度
                while (x < chars1.length && y < chars2.length) {
                    if (chars1[x] == chars2[y]) {
                        // 当前字符匹配上了之后，两个都要往后移动,比对的逻辑就是传统逻辑，没啥好说的
                        x++;
                        y++;
                    } else {
                        // 走到这里说明当前s2中y位置和s1中x位置匹配不上
                        if (next[y] == -1) {    // 用来判断当前s2的y元素是否已经走到了最开头(0)位置，TODO 也可以写成y==0
                            // 说明此时已经s2中的y下标已经走到了0位置，那么0位置的都还不匹配，x只能往后移动一位然后再接着比较了
                            // 此时y实在不能再往左跳了
                            x++;
                        } else {
                            // 如果y还没到0位置，那么就可以根据nexts[]数组对y进行再移动
                            y = next[y];
                        }
                    }
                }
                // 此时跳出,可能是因为x越界跳出了，也可能是因为y越界跳出了,也可能两个同时越界
                // 如果是y跳出了，那么此时就说明匹配上了s2元素，那么第一个匹配位置的下标就是(x-y)
                // 否则，那必然是x越界了导致跳出，x都越界了，说明肯定没找到嘛，那就返回-1
                return y == chars2.length ? (x - y) : -1;
            }
    线段树
        概述
            比如我有一个数组,现在有如下要求,在L...R这个区间都新增5,在L...R这个区间上的值都更新成8,求在L...R这个区间上的累加和...
            按照传统方式来讲,那直接拿着数组遍历就行,每次操作的时间复杂度为O(N)---N=R-L,那如果是这个接口暴露给用户,用户频繁地去调用这个方法,那每次时间复杂度为O(N)了呢,能不能提高这个速度? 线段树就是解决这样的问题
        解决什么样的问题
            区间上的统一增加,区间上的统一更新,区间上的累加和统一查询,而且速度很快,时间复杂度可以做到O(logn)级别
            递归方法实现线段树,不用担心栈溢出,深度不会太大,2的64次方级别的数据,最大深度不过64

            构建了树之后,每一个节点就表示一个区间的累加和,他顶多就走两遍树的高度,logn级别
        结构(想象出来的树形结构)
            假定数组中有4个元素,数组下标以1开始,0忽略,那么就对应一棵3层的满二叉树,叶子节点代表1-1的累加和,2-2的累加和,3-3的累加和,4-4的累加和,第二层节点代表1-2的累加和,3-4的累加和,第一层也就是根节点代表1-4的累加和...
        实现(数组实现)
            假设要求A数组的线段树,搞一个很长的数组B,0下标废弃不用,1下标开始,然后1下标就存根节点,2下标就是根节点左孩子,3下标就是根节点的右孩子,4下标是2下标的左孩子... 跟完全二叉树的思路有点像,但不是完全二叉树
                有点像按层遍历,等到有的节点已经成为叶子节点之后,那么他的左孩子右孩子所在的下标都不用啊,虽然不用,但是下标的那个位置你得占着,不能直接就从那里开始记录后边的值了
                因为可能后边的节点还有子孩子呢
            下标规律
                假如当前下标是i

                他父节点对应的下标就是: i/2, 因为是从1开始嘛,不是0
                左孩子的下标: 2*i 
                右孩子的下标: 2*i+1
            那数组B应该准备多长呢? 
                结论: 要准备4*n,绝对够用
                    最省空间的时候是原数组长度:2的某次方 的时候,最费空间的时候是原数组长度:2的某次方 + 1 的时候,但是最多也不会超过4*N
            只要知道那些叶子节点的值(就是数组中每一项的值),就可以根据上边的下标规律将其他剩下的所有节点的值推出来,节点(范围,值)
            然后这个想象的结构构建出来之后(本质是个数组啊),每次去更新一个范围上的值,都会采用"懒更新"
        "懒更新"
            搞一个"懒更新数组",和B一样长,记录每一个节点对应的"懒的记录",如果在范围更新的时候,发现到达某一个节点的时候,这个"节点范围内的所有元素都要进行更新"(比如更新3~789,要都新增5,一个节点是250~500的范围),那么这个节点就不再继续往下搜寻,而是记录一下他对应的"懒值"为5,等到第二次需求过来(比如3~789又要新增7),那么他此时已经记录了一个懒值,就将懒值下放给他的两个子节点,两个子节点会更新各自的懒值+累加和(当前累加和+=懒值*数量)然后呢,当前节点的懒值从5变回0,然后0+7=7,会变成7
                也可以不往下放,直接更新当前懒值5+7=12...
            新增
                如果全包,那就直接更新当前节点的懒信息+累加和,如果没有全包,当前懒值往下放,让两个子节点去更新懒信息+累加和,然后自己清空懒值
            更新 
                搞一个change数组,一个update数组,change数组表示当前某个范围内他们的值变成了什么,update数组是个boolean类型的,主要用来和0作为区分,数组初始值是0嘛,那如果中途我改了数组中某一段范围的值让他变成0,那到底是更新过呢还是没更新过呢? 所以用一个boolean类型的数组区分   

                更新的时候,
                    如果全包,update[]和change[]跟着改变,同时sum[]也就变成 更新后的值*范围长,lazy变为0 
                    不全包,往下涉及到的子节点也要进行更新,将他们的update都设置为true,change都设置为要更新的值,懒设置为0,累加和设置为新的(更新后的值*对应的长度)

        理解
            构建一棵树,每个节点都表示一个范围内的累加和,只不过这个节点存储的是下标,根据下标就可以找到存在数组中的累加和
            那么当新需求来的时候, 比如L...R之内需要新增5,如果全包括了当前范围,说明当前范围每一个值都需要+5,那么只对当前这个节点更新就行,增加他的懒值,更新他的累加和
            二如果不是全包,只需要加L...R中的一部分,那么如果说当前元素有懒值,就要把懒值往下放,让左右子节点都先更新各自的懒值和累加和,然后再更新当前节点的懒值+累加和,然后自己的懒值变为0

            如果全包的话,那自然只更新当前节点就够了,只需要保证累加和+懒值调对就ok了,不往下发了,这样才保证了是logn的级别,能懒则懒,往下发就不是logn的复杂度了
            如果不是的话,那就要更新子节点的信息然后再更新自己的信息



        主要就三个数组嘛,sum[],lazy[],update[],change[]
            sum[]用来记录每个范围的累加和
            lazy用来记录每个范围的懒值
            change就是用来记录每个范围的更改后的值
            update表示是否真的改变了
        实现(参考代码)
    IndexTree+AC自动机
        IndexTree
            前缀和数组存在的问题
                前缀和数组很好用,获取某个范围内的累加和可以做到O(1),极大地提升了效率
                但是有个致命的问题
                    如果在某个时刻,数组中的值发生了变动,那么此时已经生成好的前缀和数组就会失效,又要重新去算一遍前缀和数组,算的这个过程时间复杂度为O(N),那还不如不用前缀和数组呢,直接每次O(N)去扫原数组求累加和得了
                前缀和适用于那些后期值不会改变的数组

                那有没有一种解决方案,既能快速求得一个范围内的累加和,又能适应数组中值的改变呢?  使用IndexTree
                    线段树就可以解决(假设要改变i位置的值嘛,那线段树就更改i~i这个范围的值呗),但是IndexTree比线段树更好
                    IndexTree无法做到范围更新,只能做到单点更新,能做到单调更新+更新之后继续查询某个范围的累加和 两个方法都很快
            构建辅助数组思路
                搞一个和原来一样长的数组作为辅助数组,1位置就是1的累加和,2位置就是1,2位置的累加和,3位置就是自己的累加和,4位置就是1,2,3,4的累加和,5就是自己的累加和,6位置就是5,6位置的累加和,7位置就是自己的累加和,8位置就是1~8的累加和(本来是7,8的累加和,但是(7,8)是两个和前面(5,6)也是两个一样,然后可以合并变成4,正好跟1~4一样,又可以合并,就是1~8)...以此类推
            常用结论
                如果数组中一个元素的下标为index,那么他是哪些范围下标的累加和呢?
                    它管理的范围就是: 索引二进制最后一个1变为0,然后+1 ~ 他自己 
                    假设index的二进制表示为 01011100,它管辖累加和的范围: 01011001 ~ 01011100
                累加和
                    假定一个元素的下标是index,对应的二进制: 01110 那么它的累加和=自己下标对应的值+二进制去掉最后一个1之后的下标对应的值+二进制再去掉最后一个1之后下标对应的值...
                        1~index的累加和: help[01110]+help[01100]+help[01000]+help[00000]
                    help数组中不是存的每一个从头到尾的累加和,而是比较特殊的那种(管了个范围嘛)
                获取二进制中最后一位1 num&-num--->只保留最后一位1,其他位全是0
            新增/更新某个值
                肯定会影响help数组中一批数组嘛,前面的倒不会影响,主要是后面的,因为后面的会用到当前的值
                影响哪些呢? index+=index&-index;
                    比如说3下标的值变了,那么会影响4,8,16... 直至数组末尾,后边只要是囊括了3下标的,都会受到影响
                        当前index加上最右侧的1,加着加着升级到2的某次方的时候,后面都是2的某次方递增了
                在某个位置上进行新增/更新,哪些位置会受牵连...往后找
            求1~index的累加和
                index-=index&-index;
                要找到累加和是多少,那就当前自己+去掉最后一个1+去去去去去... 当然要在index>=0的范围内
            时间复杂度呢?
                有多少位就进行多少次操作嘛,logN
            L~R的累加和是多少呢?
                1~R - 1~(L-1)
            IndexTree相对于线段树优势在哪呢?
                线段树时间复杂度也是logn,但是它转成二维的时候很麻烦,IndexTree转成二维的很简单
            特点
                支持区间查询
                没有线段树那么强,但是非常容易改成一维,二维,三维的结构
                只支持单点更新
            二维===略
                就是以(1,1)开头,一直到(i,j)这中间的累加和
            代码实现
                public class IndexTree {
                    public int[] treeArr;
                    public int maxLength;
                    
                    public IndexTree(int size) {
                        maxLength = size;
                        treeArr = new int[maxLength];
                    }
                    public void add(int index, int value) {
                        if (index < 0) {
                            return;
                        }
                        // 给index位置新增值，那么受影响的下标就会是 index本身+index的二进制最后一位1... 一直加下去，直至超过数组长度
                        while (index < maxLength) {
                            treeArr[index] += value;
                            index += index & -index;
                        }
                    }
                    public int sum(int index) {
                        int result = 0;
                        while (index > 0) {
                            result += treeArr[index];
                            index -= index & -index;
                        }
                        return result;
                    }
                }
        AC自动机(前缀树上KMP)
            KMP
                给一个字符串s1,一个字符串s2,判断s1中是否有s2,并且获取s2在s1的位置
            前缀树 
                给一个字典,是个字符串数组,里面都是敏感词,构建一棵前缀树
            AC自动机
                给一篇长文章,文章中包含的每一个敏感词都要给收集到,不能漏掉,请问文章中包含了哪些敏感词?

            思路/规则
                构建好前缀树之后,对前缀树进行增强,为它新增一个fail指针,根节点的fail指针指向null,根节点下一层节点的fail指针指向根节点,然后对于其他的节点如何设置fail指针呢?根据按层遍历的顺序来

                比如遇到第三层的第一个节点,看他的父节点parent,parent到当前节点走的是b这条路,然后看parent的fail指针指向的节点(此时应该是根节点),看看根节点是否有b这条路,如果没有,那就再跳往头节点的fail节点(也就是null),null肯定也不会有b这条路嘛,走到null了都没有指向b这条路的,那当前节点的fail指针就指向头节点去
                如果中途的某个节点有指向b的路,那么这个fail指针就指向那一条b路"到达的节点"
                    就是看他父节点的fail指针指向的元素有没有到往他的路
                        有的话,当前节点的fail指针就设置为那条路的到达节点
                        没有就继续往上,如果走到null都还没找到那就将当前元素的fail指针设置为头节点
                
                fail指针的含义
                    当匹配失败的时候,fail指针所指向的表示: 剩下的后续哪一个字符串的前缀与我当前这个后缀相等的,且匹配长度最长的字符

                    作用
                        当匹配失败的时候,能够准确滴跳到可能匹配上的长度最大的敏感词,如果还是匹配不上,那几继续通过fail跳
                        所以这也就是为什么fail指针要搞最长的前缀跟后缀了,要保证每一步淘汰的都非常小心
                            顺着fail指针跳

                        比如说文章 abcdex, 敏感词有abcdef, cdey, ex 
                            那么在匹配abcdef的时候,走到f的时候发现匹配不上了,那么就去找e的fail指针,此时e的fail指针是指向cdey中的e的,所以他就直接来比对cdey...跳过了ab,宣告了ab的失败,因为ab肯定在敏感词中不存在了,那为啥不宣告c失败呢? 因为敏感词中有cde,而且是根据fail指针找到了, 找到了一个最好的最长的前缀,小心翼翼地淘汰了ab,然后又匹配,匹配到y的时候发现又不匹配,然后又根据e的fail指针来到了ex中的e
                    为啥根节点下面的节点指向头节点呢?
                        如果第二个字符都没匹配上,就应该去头节点重新匹配呢
            前缀树+fail节点就是AC自动机

            实现
                向前缀树中添加新值的时候还是跟以前一样的
                但是设置fail指针的时候,通过按层遍历,肯定要使用队列嘛,只不过在从队列中弹出元素的时候,要去提前设置他子节点的fail指针,而不是弹出谁去设置谁的fail指针(因为设置fail指针要去找他的父元素)

                文章匹配的时候---查询
                    就是要顺着fail指针走一圈,一直按照着fail蹦,这个fail蹦完蹦到下一个fail,如果蹦到null的位置还没发现endUse,那就说明当前匹配的字符无效呢,走下一个字符
                    等蹦到endUse不为空的时候,说明有个敏感词在这里结束,那这个时候就说明找到了,存入结果集中 ,一直走走走走到根节点 
            代码实现
                Node
                    public class Node {
                        // 如果当前一个节点表示一个字符串的结尾，那么会记录这个字符串
                        public String endStr;
                        // 表明当前字符串是否已经被加入到答案中
                        public boolean endUse;

                        // fail指针
                        public Node failRef;
                        // 当前节点所连接出去的路，用来表示26个字符，如果没有对应的字符，则记为null
                        public Node[] next;

                        public Node() {
                            this.endStr = null;
                            this.endUse = false;
                            this.failRef = null;
                            this.next = new Node[26];
                        }
                    }
                ACAutoMachine
                    public class ACAutoMachine {
                        // 根节点
                        public Node root;

                        public ACAutoMachine() {
                            // 头节点初始化，fail指针指向null
                            this.root = new Node();
                        }

                        /**
                        * 只是单纯滴向前缀树中插入字符串
                        * 思路
                        * 跟前缀树插入是一样的
                        *
                        * @param str 要插入的字符串
                        */
                        public void insert(String str) {
                            if (str == null || str.length() == 0) {
                                return;
                            }
                            char[] chars = str.toCharArray();
                            // 从根节点开始
                            Node ref = root;
                            for (int i = 0; i < chars.length; i++) {
                                int index = chars[i] - 'a';
                                if (ref.next[index] == null) {
                                    Node node = new Node();
                                    ref.next[index] = node;
                                }
                                ref = ref.next[index];
                            }
                            // 结尾设置endStr
                            ref.endStr = str;
                        }

                        /**
                        * 构建AC自动机(在前缀树中设置fail指针)
                        * 思路
                        * 按照按层遍历的思想，使用队列进行实现
                        * fail指针的设定要参考父节点的fail指针,而节点中没有一个属性去指向父节点，所以要在队列中弹出一个元素的时候，提前为他的子节点设置fail指针，子节点的fail指针需要参考当前节点
                        */
                        public void build() {
                            Queue<Node> nodeQueue = new LinkedList<>();
                            Node ref = root;
                            nodeQueue.add(ref);
                            while (!nodeQueue.isEmpty()) {
                                Node node = nodeQueue.poll();
                                // 如果是根节点，将他们子节点的fail指针都设置为根节点
                                if (node == root) {
                                    for (Node childNode : node.next) {
                                        childNode.failRef = node;
                                        // 同时将子节点都压入队列中
                                        nodeQueue.add(childNode);
                                    }
                                } else {
                                    // 如果不是根节点
                                    Node curFail = node.failRef;
                                    for (int i = 0; i < 26; i++) {
                                        // 如果当前路不为null，那就说明有元素，进行设置
                                        if (node.next[i] != null) {
                                            // 先默认将他的fail指针设置为null
                                            node.next[i].failRef = null;
                                            while (curFail != null) {
                                                if (curFail.next[i] != null) {
                                                    // 子节点的fail指针指向curFail的子节点,最大前缀
                                                    node.next[i].failRef = curFail.next[i];
                                                    break;
                                                }
                                                curFail = curFail.failRef;
                                            }
                                            nodeQueue.add(node.next[i]);
                                        }
                                    }
                                }
                            }
                        }

                        /**
                        * 文章中查找敏感词，并记录下来
                        * 思路
                        * 依次匹配字符，遍历文章
                        * 每次根据对应字符去匹配，一旦发现匹配不上的时候就去找他的fail指针所指的元素
                        * (要求这个fail指针的下一个字符(某一路)要和当前的字符匹配)，如果找到了根节点，没找到fail指针，那就说明当前没有对应的敏感字符，就不管了，遍历下一个字符去
                        * 然后找到了对应的fail指针的时候,指向fail.next[index]，也就是匹配的那个字符
                        * <p>
                        * 只要它不为空，那么就一直找找找，接着找他的fail指针
                        * 如果找到了，那就记录，并设置endUse，防止再次记录
                        * 如果找到root节点还没找到，那就说明没有敏感字符...
                        *
                        * @param content 文章
                        * @return 包含的敏感词结果集
                        */
                        public List<String> containsWords(String content) {
                            if (content == null || content.length() == 0) {
                                return null;
                            }
                            char[] chars = content.toCharArray();
                            // 结果集
                            List<String> result = new ArrayList<>();
                            Node ref = root;
                            // 遍历每一个字符
                            for (int i = 0; i < chars.length; i++) {
                                int index = chars[i] - 'a';

                                // 去进行匹配，当一旦发现匹配不上的时候，就走向他的fail指针所指向的节点，因为要去接着判断前缀和当前敏感词的后缀相同的最大的敏感词
                                // 走到root了那就跳出来，说明根本就没有对应的敏感字符串，因为都走到root了还没找到呢
                                while (ref.next[index] == null && ref != root) {
                                    // 说明当前没匹配上，没匹配上就去找他的fail节点

                                    // 如果走到了fail位置，发现fail位置有所期待的路，那就准备跳出来
                                    ref = ref.failRef;
                                }
                                // 当跳出上面的while循环时，说明此时已经找到了一个fail指针，并且他有一条路和当前的路匹配
                                ref = ref.next[index] != null ? ref.next[index] : root;
                                Node follow = ref;
                                // 如果走到root没找到，那就说明没有对应的敏感字符
                                while (follow != root) {
                                    if (follow.endUse) {
                                        break;
                                    }
                                    if (follow.endStr != null) {
                                        // 说明已经匹配上一个敏感词
                                        result.add(follow.endStr);
                                        follow.endUse = true;
                                    }
                                    // 然后一直往fail蹦，直到蹦到一个敏感词的结尾说明找到了，或者蹦到根节点说明没找到
                                    follow = follow.failRef;
                                }
                            }
                            return result;
                        }

                    }
    与哈希函数有关的结构
        哈希表
            概念
                哈希函数
                    实现方式
                        SHA1,SHA2,MD5,MD2,SHA-512,SHA-256...
                    特点
                        1. 输入域可以认为是无穷大(字符串,传进来个对象,就把内存地址拿过来转成字符串,传进来个整数,也是转成字符串之后再那啥),输出域可以是有限的但是也很大(比如0~2的64次方-1,0~2的128次方-1...)

                        2. 不存在随机的成分,输入相同,那么输出也必定相同
                        3. "哈希碰撞"
                            那么就可能存在一个问题了,无穷大的输入对应了有限的输出,那么必定会导致有不同的输入对应同一个输出,这个就是哈希碰撞
                                像MD5这种算出来最短的,只要不是万亿级别,不会冲突,两个不同的值算出来就是不一样
                        4. 离散性/均匀性
                            就是比如说输出就是一个轴,轴的长度比如在0~2的64次方-1,那么在大量的"不同输入"之后,很多值都会打到轴上,这个时候如果拿着同一根绳子去在范围上进行量,不管在哪个范围,绳子所能囊括到的值的数量大体上是差不多的,就是离散均匀分布
                            即便很多输入是很像的,但是还能做到均匀给他摊开,即便差别再小,也能够通过哈希函数将这一点点不同放大到很大

                            如果再将这些输出去%一个数num,那么他之前在0~2的64次方-1上均匀分布,在num这个范围内也是均匀分布的
                    算出来是十六进制
            哈希表的设计
                经典哈希表是基于数组+链表实现的
                如果不停地往哈希表中添加不同的元素,那么根据离散性+均匀性,哈希表的数组中的那些值必定是均匀增长
                为什么哈希表的CRUD都是O(1)?---扩容机制保证
                    那说不对啊,都用链表了,那时间复杂度怎么会是O(1)呢? 要遍历链表才能对元素进行操作呢,时间复杂度不就上去了吗?
                    哈希表为了解决这个问题,就采用了扩容的策略,怎么个扩容法呢,java中是链表的长度达到8之后就会进行扩容,注意: 由于具有离散性+均匀性,所以当数组中某一个下标位置存放的链表长度达到8时,此时说明其他下标位置的链表长度也是差不多到了8,此时也说明啊,当前哈希表存的元素也挺多的了,那么就会"通过扩容来保证哈希表CRUD的时间复杂度为O(1)"
                        怎么扩呢? 数组长度变为之前的两倍,然后哈希表中每一个元素重新对数组长度取模,如果下一次元素又多了,那么接着再扩,直到扩到64,如果这个时候再多,就不扩了,变红黑树了 

                    

                    没扩容之前,时间复杂度也可以理解是O(1),为啥,因为没扩容之前,数组中每一个下标位置对应的链表长度最多就是8嘛,那对元素进行一次操作,就是O(1)+8,那还是O(1)
                    


                    当然了,扩容也是有代价的,也是会影响效率的,所以在使用哈希表的时候,"建议合理定义初始长度"
                        尽量让他不扩容就可以满足需求,但是也不能设置的太大

                    算上扩容,那么对于N个元素,总代价是O(N),所以均摊到每一次的操作,时间复杂度就是O(1),扩容的次数是logN
                工程上的改进 
                    长度适中的数组+链表+红黑树,都在优化常数时间
        布隆过滤器(Bloom Filter)---黑名单+节省空间
            适用场景
                比如有个URL的黑名单集合,里面包含了很多很多的不予访问的URL(比如100亿条数据,每个url的长度不超过64字节),如果有请求过来访问这个黑名单集合中的url,直接拒绝,否则,通过
                问,怎么实现这个东东? 
                    可以用哈希表,但是空间太浪费了,一条记录就是64字节,100亿条数据,那要用6400亿子节的空间,要640G的内存才能支持这个服务,所以很deer
                    
                那咋办呢? 用"布隆过滤器"
                    用布隆过滤器可以做到18G拿下,而且失误率控制在6/10w, 不是说不能被替代,而是对于空间优化太好了,妥协的产物,看看允不允许有一点失误率...
            作用
                "解决类似黑名单这样的情形",相对来讲"很节省空间"
            失误率(宁可错杀三千不可放过一个)
                但是布隆过滤器一定有失误率,可以通过设计,将失误率控制在一定范围内

                如果一条数据在黑名单中,那么他绝对不会失误,会检测出来
                但是如果一条url"不在黑名单" 中,这个时候就可能会失误了,可能会"误报"
            如何实现的呢?
                位图
                    就是bit[]数组,但是呢,又没有bit[]数组具体的实现方式,最小就是byte了嘛,所以可以通过像比如说int[]来实现bit数组(位图),比如一个长度为10的int[]数组,那么它就可以代表一个长度为320的bit[]数组
                过程 
                    新增元素
                        bit[]数组准备好之后,就是作为布隆过滤器了,有三个哈希函数(f1,f2,f3),好那么如果要向黑名单列表中新增一个元素,那么先通过f1算出一个hash值,然后对bit[]数组长度取模,标记bit[]数组中那个下标,然后f2算一下,取模,做标记,f3算一下,取模,做标记... (可能三次算下来取模有重复的,有重复就有重复嘛,无所谓,对应位置做个标记就行)
                        下一个元素过来,也是一样的过程,三个哈希函数算,算了之后取模,做标记额
                    查询元素是否存在?
                        一个元素过来,诶经过三个哈希函数去算,算了然后各自取模,就可以得到三个位置嘛,然后去看
                            如果三个位置全做过标记,那说明之前标记过,就拒绝
                            "但凡发现一个位置之前没做过标记",那就说明当前元素之前绝对没有存过,放行

                            标记的三个位置和查询的三个位置,都是一套哈希函数嘛,算出来的值肯定都一样
                    问题来了,bit数组长度定多大? 用几个哈希函数?
                        bit数组长度如何确定?
                            bit[]长度过小肯定不行,数据量一大,全给标记了(误差大),m定太大又会存在浪费空间的问题
                            长度越大,失误率越低,但是失误率绝对避免不了,长度越小,失误率越高

                            影响的因素
                                1. 样本量
                                    样本总量多大
                                2. 失误率
                                    要求的失误率是多少
                                3. 单样本大小
                                    每一个样本的大小是多少,跟哈希函数无关
                                长度只与1,2有关,有一个公式根据样本量+失误率专门来计算数组的长度,公式无需关心啊
                                
                        哈希函数个数如何确定?
                            哈希函数太少,会因为取样不足,导致失误率上升
                            哈希函数太多,会导致算出来的结果/标记太多,从而也会导致失误率上升

                            在样本+bit数组长度确定的情况下,失误率和哈希函数个数也满足一个公式和图像(两边高,中间低)

                            先确定bit数组长度,再确定哈希函数个数
                        布隆过滤器的三个重要公式
                            假定数据量为n,预期的失误率为p(布隆过滤器大小和每个样本的大小无关)
                            根据n和p,算出布隆过滤器一功能需要多少个bit位,向上取整,记为m
                                m=-n*lnp/(ln2的平方) 
                            根据m和n,算出布隆过滤器需要多少个哈希函数,向上取整,记为k
                                k=ln2*m/n=0.7*m/n 
                            根据修正公式,算出真实的失误率 p_true(参照截图)
                        那如果算出来要十多个哈希函数,那上哪去找这十多个hash函数呢?
                            只需要得到两个就可以f1()+f2()
                            1. 1*f1()+f2()
                            2. 2*f1()+f2()
                            3. 3*f1()+f2()
                            ...
                            依次类推,他们都是几乎独立的
            还适用于HDFS中
                分布式存储嘛,分块存储,每一个块都有一个自己的小布隆过滤器,然后去找文件在哪个块的时候,就去看布隆过滤器
                    假设有三块分布式存储块123,那就对应三个布隆过滤器,然后去查的时候查布隆过滤器,发现1有标记,3也有标记,2没有,那说明肯定没在2里面嘛...
        一致性Hash(任何分布式存储的基础)
            分布式存储中最常见的结构
                哈希域变成环的设计,虚拟节点技术
            传统Hash方式
                通过资源的hash值来确定资源存储在哪台机器上,如果有很多不同的key,那么根据哈希函数的离散性+均匀性,这些值会均匀滴存储到不同的服务器上,某种程度上实现了负载均衡

                用什么值/数据来进行哈希函数计算,来确定数据在哪片上的,这个数据/值叫做"HashKey",选择一个良好的HashKey是非常重要的,要保证资源的均等分
                    比如虽然是三台服务器,通过hash算法可以对key进行均分,比如 按照国家名来分,中,美,他两可能会算到不同的服务器上去,但是由于体量比较大,可能会导致他们对应的服务器的压力也比较大,对于小日本这种小国家对应的服务器压力就不大,那这样按照国家来分,很明显是不好的,没有真正实现服务器资源均衡的目的,只实现了Hashkey的均分,业务上的不平衡也会导致负载不均
                    只能从业务上去挖掘什么数据可以做HashKey
            传统方式存在的问题
                如果加一台机器,那就GG,数据如何迁移呢? 减一台机器也GG
                一致性Hash就是解决这个问题,增加/减少机器时的数据迁移不是全量迁移,而且还能做到负载均衡
            一致性Hash思路 
                将哈希函数算出来的值想象成一个环
                    比如 0~2的64次方-1,这个范围,那就把它想成一个环,0的前面就是(2的64次方-1)
                    一致性Hash的时候没有模了,算的时候不会去模
                
                然后根据服务器的一些信息,去算他们的hash值,比如三台服务器m1,m2,m3,然后根据各自的一些基本信息(ip/mac/...)算出三个哈希值 c1,c2,c3,落在环上,那么当有数据需要进行存储的时候,对数据算一个hash值(不用模),然后在环中顺时针走,遇到的第一台服务器,就存入到这台服务器中

                如果环中重合了
                    比如m1,m2,m3三台服务器,根据服务器的ip/mac啊之类的进行hash计算,m1和m2算出来的hash值一样的,那在环上就重合了嘛,重合了就重合了,让m1和m2都去存储对应的信息嘛,但是如果是后端服务器就不能这么干了
                好处
                    数据迁移很便捷
                        上线一台新的
                            比如新增一台m4,m4的hash算出来hash值在m3--->m4--->m1之间,那么这个时候怎么迁移呢? 以前m3---m4这一段的数据是存在m1的,那这个时候只需要把这一段数据从m1拿出来放进m4中就可以了(因为可能涉及到后面要从m4中查这些数据)
                        下线一台
                            比如要下线m4,m3--->m4--->m1,直接,m4的数据全拿出来,然后顺时针找找到他的下一台就是m1,直接给m1就好了
                那怎么实现这种顺时针找呢?
                    对三台机器hash计算,比如算出来 m1:7,m2:64,m3:9, 好,把他们从小到大排序一下===> [m1:7,m3:9,m2:64], 这个时候比如我算出来一个值是56,那就去数组中找>56的最左边的位置,这样就找到了m3:64,而且也可以通过二分进行查找(有序嘛),更快,几千台几万台找起来也不是事儿
                问题
                    三台机器打到环里如何把环均分?
                        少量机器的时候,刚开始根据他们各自的信息算哈希值的时候,然后打到环上,环不会被均分
                            比如m1和m2离得比较近,m1,m2和m3离得比较远,那这样后面数据存进来,就会导致m1和m3的压力上去,因为m2到m3的距离范围比较远,那么在这个范围内的hash值的元素都会走到m3上去,m1同理
                                m1-->m2------>m3-------->m1...
                            那你说手动去设置每台机器的hash值吗? 让他们将环均等分
                                这样也不是很好,那比如说后期加机器,新加的这些机器又可能会导致环不均等
                    加机器导致环不均等咋办呢?
                        怎么解决
                虚拟节点技术解决上述两个问题
                    不让机器去抢了,而是每台机器分配节点,让他们的节点去抢
                        假如说分配1000个节点,m1(a1~a1000),m2(b1~b1000),m3(c1~c1000),然后各自的1000个节点去抢环,然后他们所占有的值最终都会归纳到m1/m2/m3中,均衡,(1/3属于m1,1/3属于m2,1/3属于m3)
                    如果是新增机器
                        新增一台m4,也会搞1000个节点,然后会从m1,m2,m3中要来相等数量(拿锤总量的的1/12,他们自己是1/3嘛,减去1/12之后就是1/4了)的信息作为自己的1/4,然后就均等了
                    既能实现负载均衡,也能实现"负载管理"
                        比如m1很强,m2,m3平庸一点,m4拉,那m1分配2000个节点,m2和m3各自分配1000个节点,m4分配500个
    有序表⭐️⭐️⭐️
        概述
            数据库索引
                数据库技术最重要的就是索引
                建立索引的一个隐含条件就是当前要用来做索引的字段要是"可排序的",任何字符串都是可排序的,如果某个字段中的值不知道如何进行排序,那是建立不了索引的
                搜索二叉树本身就支持索引,只不过有些时候遇上特殊场景很deer,变成瘸子,并且只有两个叉,固定的层存储的数据不多
                    如果搜索二叉树的高度不能达到一种很高效的目的,算法性能就由用户输入的顺序决定的
                诶? 索引不也可以用hash表嘛? 时间复杂度为O(1)更香啊
                    确实也有hash作为索引的,但是不适合范围查询嘛,而且有的时候要排序呢,做有序查询,这个hash表就办不到
                    如果查一张表只是查他在哪,只涉及到"等值查询",可以考虑hash表,很快,一旦有范围查询,有序查询这种操作,就不要用hash
            那瘸子树怎么处理呢?
                涉及到平衡搜索二叉树,如果能保证最高的高度,查询的时候也是logN的水平,平衡二叉树如何实现的呢? 左旋+右旋
        平衡搜索二叉树的左旋右旋
            左旋
                左旋的时机
                    当发现右树的高度相对于左树的高度过高(右树高度-左树高度>=2),需要进行左旋
                    那肯定嘛,右边太高了,往左给他平衡一下
                一定要指明哪个节点作为头要进行左旋,头节点向左边倒,它进行左旋就是把它放到左边去,然后右孩子上位,它作为右孩子的左节点
                流程
                    目标节点的右孩子上位,目标节点所在的树设置为它右孩子的左节点,那右孩子人家本来就有一个左节点了,咋整? 把右孩子的左节点所在的树作为目标节点的右孩子(此时目标节点下去了肯定就没有右孩子了嘛),右孩子的右节点不变
                左旋之后不会改变搜索二叉树的性质(左树的最大值比父节点小,右树的最小值比父节点大)
            右旋
                右旋的时机
                    当发现左树的高度相对于右树高度过高(左树高度-右树高度>=2),需要进行右旋
                也要指明哪个节点作为头节点进行右旋,然后头节点向右倒
                流程
                    目标节点的左孩子上移,目标节点变成它左孩子的孩子,目标节点的左孩子变成目标节点的左孩子

            "AVL树","SB树",红黑树对于平衡各有各自的实现,不管是哪种有序表,它底层的本质还是基于"左旋"+"右旋",只不过他们使用左旋右旋的策略不一样
        AVL树(自平衡二叉查找树)---就是搜索二叉树+平衡性
            概述
                AVL树拥有最严格的平衡性
                sb树,红黑树,B+树...都拥有各自的平衡性,但是他们的共同点都是时间复杂度都是O(logN)

                定义: 在AVL树中,任何一个节点的左树和右树的高度差不超过1
                在新增节点和删除节点都和搜索二叉树一样的,只不过是在新增/删除之后,有"平衡动作"

            搜索二叉树的删除操作
                1. 如果要删除的节点就是叶子节点
                    无左孩子也无右孩子,那就直接删除掉
                2. 如果要删除的节点"有左无右"
                    直接让左孩子替代当前节点就完事
                3. 如果要删除的节点"无左有右"
                    直接让右孩子替代当前节点
                4. 如果要删除的节点"有左也有右"⭐️⭐️⭐️
                    找到右树的最左边孩子,这个最左孩子替代当前要删除的节点,最左边孩子的右节点替代最左边孩子(此时注意奥,最左边孩子是没有左孩子的)
                    或者 
                    找到左树的最右边孩子,这个最右边节点替代当前要删除的节点,最右边节点的做节点替代最右边节点(此时最右边孩子是没有右节点的)
                    原因
                        右树的最左边孩子,很明显是右树中最小的节点,而他呢,肯定比目标节点大,所以把它换上去,他会比目标节点的左树所有值都大,而且比目标节点的所有值都小,不会破坏搜索性
                        or 
                        左树的最右边孩子,那肯定是左树中的最大值嘛,放到目标节点的位置,肯定比左树中的孩子都大,比右树中的孩子都小,所以也不会破坏搜索性
                    本质 
                        本质就是找一个比当前节点左边所有值都大,比当前节点右边所有值都小的节点
                            即: 左边的最大值 or 右边的最小值

            AVL树就是一棵标准的搜索二叉树,它该怎样加节点就怎样加,该怎么删就怎样删,只不过新增/删除之后要去平衡,那怎么去平衡呢? 这个就要从怎样破坏平衡性说起
            平衡性的规定
                左树和右树的高度差不超过1
                所以节点维护的平衡因子是高度
            破坏AVL树平衡性的四种类型
                LL+LR+RR+RL 
                LL型
                    目标节点的左边总共高出两,且各自都是左节点
                    解决 
                        只对目标节点做一次右旋就可以
                LR型
                    目标节点的左边总共高出两,上边的是左节点,下边的是右节点
                    目标节点的右树高度比较小,左树高度比较大,且左树中右树的高度较大,这个就是LR
                    解决
                        进行两次旋转
                        1. 在目标节点的左树中,让目标节点的左子节点做一次左旋
                            左树中肯定是右边的高度要高一些嘛,那就让他左旋,让整个部分变成LL,那变成LL了就好办了,直接来整个部分(头节点)再来一次右旋就OK了
                            即便此时目标节点的左子节点是平衡的,也让他左旋
                        2. 对目标节点做一次右旋

                        本质就是让孙儿上去替换掉目标节点,啥是孙儿: 只要是LR类型的,就是目标节点的左子节点的右子节点
                            要想上去替换,那就得通过左旋和右旋实现
                        先让孙儿左旋让整个结构变成LL,然后对于LL,目标节点再右旋变平衡
                RR型
                    目标节点的右边总共高出两,且各自都是右节点
                    解决 
                        只做一次左旋就可以
                RL型
                    目标节点的右边总共高出两,上边的那个是右节点,下边那个是左节点
                    解决方案
                        同理
                        孙儿: 目标节点的右子节点的左子节点
                        先让孙儿右旋,然后再让目标节点(爷爷)左旋
                        
                        孙儿R旋,爷爷L旋
                注意 
                    可能出现 既是LL也是LR,既是RR也是RL,但是不可能同时出现LL+RR/RR+LL 

                    既是LL,也是LR
                        怎么判断是不是这种情况
                            LL也违背了平衡,LR也违背了平衡
                            违背平衡来自LL,同时也来自LR

                            目标节点左子树比右子树高,且单看 目标节点+目标节点的左子节点+目标节点的左子节点的左子树(不看目标节点的左子节点和其右子树),高度还是比目标节点的右子树高2,这个就是LL
                            单看 目标节点+目标节点的左子节点+目标节点的左子节点的右子树,高度还是比目标节点的右子树高2,这个就是LR
                            两种情况都满足,那就是LL+LR 
                        要按照LL型来进行调整,直接目标节点右旋完事
                        如果仍旧按照LR的来进行调整,那有时候正确,有时候不正确,但是按照LL的来一定正确,因此"一定要按照LL来调整"
                    既是RR,也是RL
                        怎么判断是不是这种情况
                            RR也违背了平衡,RL也违背了平衡
                            违背平衡来自RR,同时也来自RL
                        要按照RR型来进行调整,直接目标节点左旋完事
                调整平衡的时间复杂度是O(1),因为只是相当于元素节点互换了
            那如何判断四种类型中了哪个呢?
                新增一个节点
                    新增的元素看看四种类型中中了哪个,再去看他父节点中了哪个...一直看到头节点为止
                    所以AVL树不是只针对某一个节点进行检查,而是"对加入节点的时候途中经过的每一个节点进行检查"
                        他沿途经过logN个节点嘛,而就算要进行调整,时间负载度又是 O(logN),所以即便每个节点都调整一遍,那调整的时间复杂度也就是O(logN)
                删除一个节点
                    1. 如果删除的是叶子节点 
                        那么要检查删除的节点,它上面的父节点,父节点的父节点,是中了四种破坏平衡中的哪一个类型
                    2. 如果删除的节点没有左孩子,只有右孩子
                        那么按照搜索二叉树的删除规则,右孩子直接上去顶替掉要删除的节点即可
                        替换之后,检查这个新上来的右孩子位置,以及它的所有父节点有没有中四种类型中的一种
                    3. 如果删除的节点只有左孩子,没有右孩子
                        同上
                            按照搜索二叉树的删除规则,左孩子直接顶替掉要删除的节点即可
                            替换之后,从这个位置开始检查,以及它的所有父节点中有没有四种类型中的一种
                    4. 如果删除的节点,既有左孩子,也有右孩子⭐️⭐️⭐️
                        按照搜索二叉树的删除规则,此时就是将右树中最左边的孩子顶替掉要删除的节点
                        那从哪里开始检查平衡性呢?
                            从"右树中最左边的孩子的父节点"开始往上检查,删除掉"右树中最左边的孩子的父节点"
            平衡树里面,递归和非递归实现是没啥差别的,递归的时间复杂度也就O(logN),栈一般不会爆,平衡树的性质保证了它特别平衡
            代码实现
                public class AVLNode<K extends Comparable<K>, V> {
                    // key,作为在平衡树中排序的依据,所以必须要求继承Comparable,可比较
                    public K key;
                    // key对应的值
                    public V value;
                    // 左子节点
                    public AVLNode<K, V> leftChild;
                    // 右子节点
                    public AVLNode<K, V> rightChild;
                    // 当前节点所在树的高度,用来判断当前子树部分是否平衡
                    public int height;
                    // 构建一颗节点
                    public AVLNode(K key, V value) {
                        this.key = key;
                        this.value = value;
                        this.height = 1;
                    }
                }
                public class AVLTreeMap<K extends Comparable<K>, V> {

                    // AVL树的根节点
                    public AVLNode<K, V> root;

                    public int size;

                    /**
                    * 初始化
                    */
                    public AVLTreeMap() {
                        this.root = null;
                        this.size = 0;
                    }


                    /**
                    * 获取某个节点的高度信息
                    *
                    * @param avlNode 要获取高度的节点
                    * @return 高度
                    */
                    private int getHeight(AVLNode<K, V> avlNode) {
                        return Math.max(avlNode.leftChild == null ? 1 : avlNode.leftChild.height + 1, avlNode.rightChild == null ? 1 :
                                avlNode.rightChild.height + 1);
                    }

                    /**
                    * 对某个节点进行右旋
                    * 思路
                    * 右旋嘛，左边的子树太高了，才会进行右旋
                    * 目标节点变成它左孩子的右孩子，它左孩子的右孩子变为它自己的左孩子
                    *
                    * @param avlNode 要进行右旋的节点
                    * @return 右旋之后的新节点
                    */
                    public AVLNode<K, V> rightRotate(AVLNode<K, V> avlNode) {
                        if (avlNode == null) {
                            return null;
                        }
                        AVLNode<K, V> leftChild = avlNode.leftChild;
                        avlNode.leftChild = leftChild.rightChild;
                        leftChild.rightChild = avlNode;

                        // 重新计算他们的高度
                        // 此时原avlNode处于下方，因此要先进行计算,就是比较两边子树的高度谁大
                        avlNode.height = getHeight(avlNode);

                        leftChild.height = getHeight(leftChild);

                        // 返回右旋之后，上位的新的节点
                        return leftChild;
                    }


                    /**
                    * 左旋
                    *
                    * @param avlNode 要进行左旋的节点
                    * @return 左旋之后，上位的新节点
                    */
                    public AVLNode<K, V> leftRotate(AVLNode<K, V> avlNode) {
                        if (avlNode == null) {
                            return null;
                        }
                        AVLNode<K, V> rightChild = avlNode.rightChild;
                        avlNode.rightChild = rightChild.leftChild;
                        rightChild.leftChild = avlNode;

                        // 计算高度
                        avlNode.height = getHeight(avlNode);
                        rightChild.height = getHeight(rightChild);

                        return rightChild;
                    }


                    /**
                    * 从avlNode节点开始(一般传入根节点)，新增一个节点，小的放它右边，大的放他左边
                    * 搜索二叉树的新增+平衡
                    *
                    * @param avlNode 从哪个节点开始新增，一般来讲是root节点
                    * @param key     要进行新增的值的key，用来排序用的
                    * @param value   要新增值的value
                    * @return 新增之后，调整了平衡之后的新节点/那一部分子树的头节点
                    */
                    private AVLNode<K, V> addNode(AVLNode<K, V> avlNode, K key, V value) {
                        if (avlNode == null) {
                            return new AVLNode<>(key, value);
                        } else {
                            if (key.compareTo(avlNode.key) < 0) {
                                // 如果要新增的节点key比当前节点小，那么应该加到当前节点的左边去,新增涉及到调节树的平衡，所以要重新设置当前节点的左节点为新增后返回的节点
                                avlNode.leftChild = addNode(avlNode.leftChild, key, value);
                            } else {
                                avlNode.rightChild = addNode(avlNode.rightChild, key, value);
                            }

                            // 然后重新调整当前节点的高度
                            avlNode.height = getHeight(avlNode);
                            // 上面都是普通的搜索二叉树元素新增
                            // 新增之后，avl树嘛，肯定涉及到要对当前节点所在的树进行平衡操作
                            return maintainBalance(avlNode);
                        }
                    }

                    /**
                    * 调整平衡性
                    *
                    * @param avlNode 要调整平衡性的节点
                    * @return 调整平衡之后的 新节点,就是那一部分的根节点
                    */
                    private AVLNode<K, V> maintainBalance(AVLNode<K, V> avlNode) {
                        if (avlNode == null) {
                            return null;
                        }


                        AVLNode<K, V> leftChild = avlNode.leftChild;
                        AVLNode<K, V> rightChild = avlNode.rightChild;

                        int leftHeight = leftChild.height;
                        int rightHeight = rightChild.height;

                        // 比对两边的高度
                        // 如果不平衡
                        if (Math.abs(leftHeight - rightHeight) > 1) {
                            // 左树高
                            if (leftHeight > rightHeight) {
                                int leftLeftHeight = leftChild != null && leftChild.leftChild != null ? leftChild.leftChild.height : 0;
                                int leftRightHeight = leftChild != null && leftChild.rightChild != null ? leftChild.rightChild.height : 0;
                                // >=包含了 LL, LL+LR
                                if (leftLeftHeight >= leftRightHeight) {
                                    avlNode = rightRotate(avlNode);
                                } else {
                                    // 要不然，就是单独的LR, 先对左孩子进行左旋，然后对自己进行右旋
                                    leftChild = leftRotate(leftChild);
                                    avlNode = rightRotate(avlNode);
                                }
                            } else {
                                // 右树高
                                int rightRightHeight = rightChild != null && rightChild.rightChild != null ? rightChild.rightChild.height : 0;
                                int rightLeftHeight = rightChild != null && rightChild.leftChild != null ? rightChild.leftChild.height : 0;

                                if (rightRightHeight >= rightLeftHeight) {
                                    // 包含 RR, RR+RL,只进行右旋操作
                                    avlNode = leftRotate(avlNode);
                                } else {
                                    // 只是RL类型，要对右孩子进行右旋，然后对当前节点左旋
                                    rightChild = rightRotate(rightChild);
                                    avlNode = leftRotate(avlNode);
                                }

                            }
                        }
                        return avlNode;
                    }

                    /**
                    * avl树中删除一个节点，并维持平衡
                    *
                    * @param avlNode 从哪个节点开始往下扫描
                    * @param key     要删除节点的key值
                    * @return 删除之后，进行平衡操作之后的新节点
                    */
                    public AVLNode<K, V> deleteNode(AVLNode<K, V> avlNode, K key) {
                        if (key.compareTo(avlNode.key) < 0) {
                            // 说明要删除的节点在当前节点的左边
                            avlNode.leftChild = deleteNode(avlNode.leftChild, key);
                        } else if (key.compareTo(avlNode.key) > 0) {
                            avlNode.rightChild = deleteNode(avlNode.rightChild, key);
                        } else {
                            // 如果发现要删除的节点就是当前节点，那么就要分情况讨论
                            // 当前节点是叶子节点
                            if (avlNode.leftChild == null && avlNode.rightChild == null) {
                                // 那么就直接进行删除
                                avlNode = null;
                            } else if (avlNode.leftChild != null && avlNode.rightChild == null) {
                                // 有左孩子，但是没有右孩子,那么左孩子直接上移
                                avlNode = avlNode.leftChild;
                            } else if (avlNode.leftChild == null && avlNode.rightChild != null) {
                                // 有右孩子，但是没有左孩子，那么右孩子直接上移
                                avlNode = avlNode.rightChild;
                            } else {
                                // 既有左孩子，也有右孩子
                                // 找到当前节点的右孩子的最左孩子,然后让他取代当前节点
                                AVLNode<K, V> desNode = avlNode.rightChild;
                                while (desNode.leftChild != null) {
                                    // 一直走到最左边的节点
                                    desNode = desNode.leftChild;
                                }
                                // 这里就是调整当前节点右树的平衡性了，就不用再去找到最左边节点的父亲节点，然后一层一层往上去调整平衡性了
                                avlNode.rightChild = deleteNode(avlNode.rightChild, desNode.key);

                                // 让最左边节点des取代当前节点
                                desNode.leftChild = avlNode.leftChild;
                                desNode.rightChild = avlNode.rightChild;
                                avlNode = desNode;
                            }
                        }
                        // 上面都是常规的搜索二叉树删除节点,然后要重新设置高度
                        if (avlNode != null) {
                            avlNode.height = getHeight(avlNode);
                        }
                        // 接下来要进行调整平衡性
                        return maintainBalance(avlNode);
                    }

                    public int getSize() {
                        return this.size;
                    }

                    // 查找...

                }
            有序表和AVL树的关系
                有序表是一种抽象出来的结构,可以想成是一个接口/规范
                而搜索二叉树,AVL树,SB树,红黑树,跳表,23树,B树,B+树都可以看作是对于有序表的实现,他们的效率和时间复杂度都一样,都是O(logN)
                搜索二叉树就能完成有序表的所有功能,其他的结构只是增加了平衡性

            B树,B+树相对于AVL树提升了常数时间,而整体的时间复杂度都是O(logN)
        SB树(SizeBalanced Tree)
            概述
                也拥有左旋和右旋两个操作,只不过和AVL树的平衡策略不一样
            平衡性的规定
                任何一个叔叔节点所在子树的节点个数 不小于 它任何一个侄子节点所在子树的节点个数
                如果每个叔叔节点都满足这个标准,那么就说整棵树是SizeBalancedTree

                所以节点维护的平衡因子是 size(当前节点所在子树的节点个数)
            特点
                它不像AVL树那么严苛的平衡性,但是他的平衡性也是非常有效的
                    假设左边节点比较少,右边节点比较多,那么根据上面的平衡性规定,右树不会比左边节点多出一倍,规模差距不会到两倍以上,高度也还是logN水平
                
                平衡性受到了一系列的阉割,为了IO小,不要那么频繁地变动
                    平衡性太严格了,那就导致稍操作一下节点,就要去平衡,然后内部结构发生变动
            破坏SB树平衡性的四种类型
                调整平衡性的方法是m(node)
                调整都是写在维持平衡性的方法m()里的
                LL型
                    目标节点的左孩子的左孩子"节点个数">目标节点的右孩子"节点个数"
                    解决
                        右旋,然后将有数量更改的节点(新上位节点的右子节点(之前的父节点),后来新上位的节点)再递归调用一次m(),重复地查有没有违规
                            因为你节点数量变了,而sb树又是通过节点数量来判断,所以对于那些数量变化的节点,那可能内部又不平衡了呢? 因此需要重新检查
                LR型
                    目标节点的左孩子的右孩子"节点个数">目标节点的右孩子"节点个数"
                    解决 
                        也是孙儿左旋,然后整体右旋
                        旋转之后对于那些数量发生变化的节点重新递归调平,LR涉及3个数量变动的节点
                RR型
                    目标节点的右孩子的右孩子"节点个数">目标节点的左孩子"节点个数"
                    解决 
                        左旋,然后将有数量更改的节点再递归调用m(),重复地查有没有违规
                RL型
                    目标节点的右孩子的左孩子"节点个数">目标节点的左孩子"节点个数"
                调整的策略和AVL树是一样的,只不过是调整之后要进行对应的递归调整
            注意
                SB树的平衡性没有像AVL树那么敏感,只需要保证左右两边节点的差距不超过差值的两倍以上即可,不像avl树,但凡涉及到新增/删除就要检查是否平衡,因此avl树不会雪崩(突然很多个节点都不平衡)
                SB树不是的,他可能是新增/删除了很多个之后才调整一次(可能会导致雪崩),那么均摊下来,调整一次平衡性的时间复杂度为O(logN)

            新增一个节点,跟avl树一样,从添加的节点开始,从下往上沿途的节点都要调整平衡性
            删除一个节点也是一样,从删除的节点开始,从下往上的节点都要调整平衡性

            SB树在删除节点的时候,删完之后不去检查平衡性,管他平不平衡,不平衡也不管,只在新增的时候检查平衡性并调整,平衡调整是递归行为,平衡调整会进行传递,依然可以将树调平
                这也就是为什么非常建议通过SB树去改有序表,省掉了删除节点时调整平衡的操作
            那不对啊,这样有问题啊
                比如一棵SB树刚开始非常平衡的,删删删,删的变成棒状结构了,也就是瘸子树了,而且后期也不会新增值,那也就是说后期没有机会让他去平衡了,那这样效率性能不就很deer了吗?
                所以说,SB树的性能是: 加入所有数据曾经冲到的最大的高度N
                    比如加了7个元素,那么高度来到了3,这样的话,即便最差情况,那也就是查3次,所以就是加入所有数据之后的最大高度,那就是logNMAX嘛
                    就算之前加了2的64次方个元素,那删成瘸子了,高度也就最多64嘛,一旦后期加入新的元素,又能立马调平
                    只是在删除和下一次新增的这个时间段内的性能会下降,而且下降也下降不到哪去
            所以SB树是一个能少调就少调,哪怕牺牲一时的性能的结构
                牺牲的这点性能就是时间复杂度变成了O(logNMAX)嘛,而且只要你后期有新增元素,迅速就能将结构调平
            总结
                新增之后要维护平衡性,删除之后可以无需管他(也可以加上)
                    那么删除之后可能就不平衡了,不平就不平,所以他不像avl树要求那么严格
                那说,avl树也可以删除的时候不检查平衡啊,在新增的时候检查平衡,那不也一样吗? 时间复杂度也是O(logN)
                    应该也确实是这样,但是可能需要加入较多的节点才能恢复整体的平衡性,他就是去检查有限个节点数量,不会去进行递归进行判断
                        比如我删删删,不平衡了,然后新增的时候,我只在下面某个位置新增,那他就只会检查到这一部分结束,而对于上面不平衡的点就管不了了,那可能需要多加几个才能检测到然后调平
                        而SB树有传递性啊,递归传递,可能加一个节点就传到根节点去了...
                    但是如果从root节点开始加入⭐️
                        但是也可能保证不了平衡,avl只是沿途检查了两遍的高度差,但是实际上可能要加入的节点全在A节点的右边,那么他沿途只会经过A的右边所有节点,而此时添加完成,调整到A的时候,A的左树和右树高度可能相等,但是A的左边实际是不平的,因为如果采用删了不调整平衡性,对于左边不平衡,它是检测不到的,而这个时候新增元素的时候他也没检测出来,只是知道左右两边高度相等,那添加完这个之后可能还是不平衡,所以可能需要添加很多节点之后才能将整棵树调整平衡

                        而SB树加一个或者少量几个就能将树调平,因为他的平衡调整是递归的

            TreeSet和TreeMap底层是用红黑树实现的
                底层实现了很多方法,但是没有实现: 比如TreeMap中添加了很多key,问: <=7的key有多少个? 
                如果涉及到这种,只能自己改有序表了
            代码实现
                public class SBTNode<K extends Comparable<K>, V> {

                    public K key;
                    public V value;

                    public SBTNode<K, V> leftChild;
                    public SBTNode<K, V> rightChild;

                    public int size;

                    public SBTNode(K key, V value) {
                        this.key = key;
                        this.value = value;
                        size = 1;
                    }
                }
                public class SizeBalancedTreeMap<K extends Comparable<K>, V> {
                    public SBTNode<K, V> root;
                    /**
                    * 获取某一个节点所包含的节点数
                    *
                    * @param node 节点
                    * @return size
                    */
                    private int getSize(SBTNode<K, V> node) {
                        return (node.leftChild == null ? 0 : node.leftChild.size) + (node.rightChild == null ? 0 :
                                node.rightChild.size) + 1;
                    }

                    /**
                    * 右旋
                    * 思路
                    * 旋转的思路跟以前是一样的
                    *
                    * @param sbtNode 要进行右旋的目标节点
                    * @return 返回右旋之后，调整了平衡的新节点
                    */
                    public SBTNode<K, V> rightRotate(SBTNode<K, V> sbtNode) {
                        if (sbtNode == null) {
                            return null;
                        }
                        SBTNode<K, V> leftChild = sbtNode.leftChild;
                        sbtNode.leftChild = leftChild.rightChild;
                        leftChild.rightChild = sbtNode;
                        // 为上来的新节点设置节点个数
                        leftChild.size = sbtNode.size;
                        leftChild.size = getSize(leftChild);
                        return leftChild;
                    }

                    /**
                    * 左旋
                    *
                    * @param sbtNode 要进行左旋的目标节点
                    * @return 左旋之后的根节点
                    */
                    public SBTNode<K, V> leftRotate(SBTNode<K, V> sbtNode) {
                        if (sbtNode == null) {
                            return null;
                        }
                        SBTNode<K, V> rightChild = sbtNode.rightChild;
                        sbtNode.rightChild = rightChild.leftChild;
                        rightChild.leftChild = sbtNode;
                        // 为上来之后的新节点蛇追size
                        rightChild.size = sbtNode.size;
                        rightChild.size = getSize(rightChild);
                        return rightChild;
                    }

                    /**
                    * 调整平衡性
                    * 思路
                    * 根据四种类型(节点个数)调整平衡性
                    *
                    * @param sbtNode 要进行调整的目标节点
                    * @return 返回调整之后的新节点
                    */
                    private SBTNode<K, V> maintainBalance(SBTNode<K, V> sbtNode) {

                        if (sbtNode == null) {
                            return null;
                        }

                        int leftChildSize = sbtNode.leftChild != null ? sbtNode.leftChild.size : 0;
                        int leftLeftChildSize = sbtNode.leftChild != null && sbtNode.leftChild.leftChild != null ?
                                sbtNode.leftChild.leftChild.size : 0;
                        int leftRightChildSize = sbtNode.leftChild != null && sbtNode.leftChild.rightChild != null ?
                                sbtNode.leftChild.rightChild.size : 0;


                        int rightChildSize = sbtNode.rightChild != null ? sbtNode.rightChild.size : 0;
                        int rightRightChildSize = sbtNode.rightChild != null && sbtNode.rightChild.rightChild != null ?
                                sbtNode.rightChild.rightChild.size : 0;
                        int rightLeftChildSize = sbtNode.rightChild != null && sbtNode.rightChild.leftChild != null ?
                                sbtNode.rightChild.leftChild.size : 0;

                        // LL
                        if (leftLeftChildSize > rightChildSize) {
                            // 右旋,然后根据节点个数调整平衡性
                            sbtNode = rightRotate(sbtNode);
                            // LL型,由于节点数量发生了变化，所以需要递归调整平衡性
                            // 先原来的父节点,再调整新上位的新节点
                            sbtNode.rightChild = maintainBalance(sbtNode.rightChild);
                            sbtNode = maintainBalance(sbtNode);
                        } else if (leftRightChildSize > rightChildSize) {// LR
                            // 先左旋，再右旋
                            sbtNode.leftChild = leftRotate(sbtNode.leftChild);
                            sbtNode = rightRotate(sbtNode);

                            // 递归调整平衡性,顺序不能乱
                            sbtNode.leftChild = maintainBalance(sbtNode.leftChild);
                            sbtNode.rightChild = maintainBalance(sbtNode.rightChild);
                            sbtNode = maintainBalance(sbtNode);
                        } else if (rightRightChildSize > leftChildSize) {// RR
                            // 左旋
                            sbtNode = leftRotate(sbtNode);
                            sbtNode.leftChild = maintainBalance(sbtNode.leftChild);
                            sbtNode = maintainBalance(sbtNode);
                        } else if (rightLeftChildSize > leftChildSize) {// RL
                            // 先右旋，再左旋
                            sbtNode.rightChild = rightRotate(sbtNode.rightChild);
                            sbtNode = leftRotate(sbtNode);

                            sbtNode.leftChild = maintainBalance(sbtNode.leftChild);
                            sbtNode.rightChild = maintainBalance(sbtNode.rightChild);
                            sbtNode = maintainBalance(sbtNode);
                        }

                        return sbtNode;
                    }

                    /**
                    * 新增
                    *
                    * @param sbtNode
                    * @param key
                    * @param value
                    * @return
                    */
                    private SBTNode<K, V> addNode(SBTNode<K, V> sbtNode, K key, V value) {
                        if (sbtNode == null) {
                            return new SBTNode<>(key, value);
                        } else {
                            // 节点数量+1
                            sbtNode.size++;
                            if (key.compareTo(sbtNode.key) < 0) {
                                sbtNode.leftChild = addNode(sbtNode.leftChild, key, value);
                            } else {
                                sbtNode.rightChild = addNode(sbtNode.rightChild, key, value);
                            }
                            return maintainBalance(sbtNode);
                        }
                    }


                    /**
                    * 根据key值删除节点
                    * ⭐️⭐️⭐️ 删除的时候不需要调整平衡性
                    *
                    * @param sbtNode 从哪里进行删除
                    * @param key
                    * @return
                    */
                    private SBTNode<K, V> deleteNode(SBTNode<K, V> sbtNode, K key) {
                        if (sbtNode == null) {
                            return null;
                        }
                        sbtNode.size--;
                        if (key.compareTo(sbtNode.key) < 0) {
                            sbtNode.leftChild = deleteNode(sbtNode.leftChild, key);
                        } else if (key.compareTo(sbtNode.key) > 0) {
                            sbtNode.rightChild = deleteNode(sbtNode.rightChild, key);
                        } else {
                            // 当前节点就是要进行删除的节点
                            // 分情况判断
                            if (sbtNode.leftChild == null && sbtNode.rightChild == null) {
                                sbtNode = null;
                            } else if (sbtNode.leftChild != null && sbtNode.rightChild == null) {
                                sbtNode = sbtNode.leftChild;
                            } else if (sbtNode.leftChild == null && sbtNode.rightChild != null) {
                                sbtNode = sbtNode.rightChild;
                            } else {
                                // 既有左子节点，也有左子节点

                                // 找到右树的最左边节点
                                SBTNode<K, V> pre = null;

                                SBTNode<K, V> des = sbtNode.rightChild;
                                des.size--;
                                while (des.leftChild != null) {
                                    pre = des;
                                    des = des.leftChild;
                                    des.size--;
                                }
                                if (pre != null) {
                                    pre.leftChild = des.rightChild;
                                    des.rightChild = sbtNode.rightChild;
                                }
                                des.leftChild = sbtNode.leftChild;
                                des.size = getSize(des);
                                sbtNode = des;
                            }
                        }
                        // maintainBalance(sbtNode);
                        return sbtNode;
                    }

                }
        
        积压结构
            比如说arraylist动态数组,当数据量变大的时候,会涉及到扩容,那么就会在扩容的这个时刻迎来性能瓶颈
                单次时间复杂度均摊下来就是O(1)
            哈希表也是如此,扩容的时候会有性能瓶颈,均摊下来很省O(1)

            "avl就不属于积压结构",而SB树,红黑树都"属于积压结构",单点可能会迎来一个瓶颈,但是总体收敛下来,时间复杂度为O(logN)
                这也就是为什么B树,B+树,234树,红黑树等"积压结构"流行的原因
                    AVL树这种结构对应平衡是很敏感的,在内存或者CPU的缓存里可能速度还可以,但是如果放在磁盘里面就可能会涉及到很频繁的IO,调整一下平衡性就要IO一下,太敏感了,很大概率会触及到磁盘的瓶颈
                    而234树,B树,B+树,红黑树往往用来硬盘结构上,那是因为他可以很久不调整一次(平衡性很模糊,没那么严格),降低IO次数,很长时间可以不变动,很长时间不触及到IO
                    

            而如果某一天磁盘的速度啊其他之类的,跟CPU/内存一样快了,那么这些积压结构可能就会走向没落
        跳表
            概述
            思路
                假定最左边head节点是最小的,随机生成一个数作为层(按照0.5的概率生成,0.5概率不动,0.5概率上升),然后呢,从这个层开始,看最左边的那个结构,从最高层开始,沿着链表找,找到一个第一个比当前值大的,然后将当前值插入到中间,然后又去下一层的这个位置开始(尽可能的往左动)

                这样下来,第一层大致就是N个节点,第二层就是N/2个,第三层就是N/4个
                    随机生成就是0.5的概率,那到第二层就是0.5嘛,所以是N/2,到第三层就是0.5*0.5了,要随机两次嘛... 每上一层都要多抛一次硬币
                随机算,算出可能要走到多少层,那就走到多少层,超过了最大层数那也认了,那就一直加加加,加到当前最高层,最高高度更新
                时间复杂度O(logN)
                一直从上边往下蹦蹦蹦,蹦到最底层
            新增
                先判断当前跳表中存不存在这个元素
                    就是走到最下面那一层判断嘛,然后找到比这个值小的最近的一个元素,然后看他的后一个跟当前值的key是否相等,相等就替换,不想等就准备新增
                随机算出层数
                    如果算出来的层比当前最大层的值大,那就更新,并且生成一些层
                    然后就从上往下将当前目标值塞进去嘛
            更新 
                只能先删掉,再添加
                
            跳表,SB树,AVL树都能改出有序表中所有的功能,用SB树改可能好改一点
        红黑树 
            定义 
                1. 每一个节点不是红就是黑
                2. 整棵树的头节点一定是黑,叶节点是包括null节点的,所以叶子节点也为黑
                3. 每个红色节点的两个子节点都是黑色的(从每个叶子到根的所有路径上不可能有两个连续的红色节点)
                4. 每一棵子树到其每个叶子的所有路径都包含相同数目的黑色节点
            平衡性 
                根据第四个定义,每一条链到达叶子节点都包含相同数目的黑色节点,所以最长的链一定是红黑红黑相间的,最短的一定是全是黑的
                因此,判定平衡性的条件就是: 
                    每一颗子树最长链的长度不会超过最短的链的长度的2倍,也是一种模糊的平衡性,这也说明整体下来左边的节点个数和右边的节点个数是差不多的
            也是为了防止像AVL树那样敏感
            违规类型
                插入5种,删除13种
            调整的代价和敏感度很小,对内存/硬盘的IO消耗比较低



                


            

    红黑树,B树,B+树,23树,234树只会聊概念,不会考实现

